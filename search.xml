<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHPmailer</title>
      <link href="/2020/03/10/PHPmailer/"/>
      <url>/2020/03/10/PHPmailer/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Golang-学习笔记</title>
      <link href="/2020/02/28/Golang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/02/28/Golang-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-读写分离</title>
      <link href="/2020/02/18/Mysql-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
      <url>/2020/02/18/Mysql-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>binlog 是 Mysql Sever 层维护的一种二进制日志，与 innodb 引擎中的 redo/undo log 是完全不同的日志；其主要是用来记录对 Mysql 数据更新或潜在发生更新的 SQL 语句，记录了所有的 DDL 和 DML (除了数据查询语句)语句，并以<code>事务</code>的形式保存在磁盘中，还包含语句所执行的消耗的时间，Mysql 的二进制日志是事务安全型的。</p><p>一般来说开启二进制日志大概会有 1% 的性能损耗(参见 MySQL 官方中文手册 5.1.24 版)。</p><p>作用主要有：</p><ul><li>复制：MySQL Replication在 Maste r端开启 binlog，Master 把它的二进制日志传递给 slaves 并回放来达到 master-slave 数据一致的目的 </li><li>数据恢复：通过 mysqlbinlog 工具恢复数据</li><li>增量备份</li></ul><p>二进制日志包括两类文件：二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件，二进制日志文件（文件名后缀为.00000*）记录数据库所有的 DDL 和 DML (除了数据查询语句)语句事件。</p><h3 id="主数据库"><a href="#主数据库" class="headerlink" title="主数据库"></a>主数据库</h3><pre><code>1、修改 Mysql 配置文件  注：Mysql 5.7.2 以后没有默认配置了，一切配置需要自行配置vim /etc/mysql/my.cnfserver-id=1           # 服务器唯一IDlog-bin=mysql-bin     # mysql-bin日志前缀，可自定义binlog-do-db=db1,db2  # 需要同步的库binlog-ignore-db=db1,db2 # 忽略不同步的库binlog 两参数2选1 都不写全部同步2、查询 bin-log 是否开启show variables like &#39;%log_bin%&#39;;+---------------------------------+--------------------------------+| Variable_name                   | Value                          |+---------------------------------+--------------------------------+| log_bin                         | ON                             || log_bin_basename                | /var/lib/mysql/mysql-bin       || log_bin_index                   | /var/lib/mysql/mysql-bin.index || log_bin_trust_function_creators | OFF                            || log_bin_use_v1_row_events       | OFF                            || sql_log_bin                     | ON                             |+---------------------------------+--------------------------------+6 rows in set (0.01 sec)3、在主服务器上建立帐户并授权# 以下为 5.x 版本 创建用户并且授权grant  replication slave  on *.*  to &#39;daofaziran&#39;@&#39;%&#39; identified by &#39;654321&#39;;# 以下为 8 版本 创建用户并且授权create user ‘daofaziran’@‘%’ identified by ‘123456’;grant all privileges on *.* to ‘daofaziran’@’%’ with grant option; flush privileges;4、查看状态show master status;# File 和 Position 要记录好+------------------+----------+--------------+------------------+-------------------+| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |+------------------+----------+--------------+------------------+-------------------+| mysql-bin.000001 |      155 | wangzhuan    |                  |                   |+------------------+----------+--------------+------------------+-------------------+1 row in set (0.00 sec)</code></pre><h3 id="从数据库"><a href="#从数据库" class="headerlink" title="从数据库"></a>从数据库</h3><pre><code>1、修改 Mysql 配置文件 vim /etc/mysql/my.cnfserver-id=2           # 服务器唯一IDlog-bin=mysql-bin     # mysql-bin日志前缀以下可选参数：replicate-do-db=db1,db2replicate-ignore-db=db1,db22、进入mysqlstop slave; CHANGE MASTER TO  # 主服务器地址  MASTER_HOST=&#39;192.168.1.6&#39;,  # 主服务器账号  MASTER_USER=&#39;daofaziran&#39;,  # 主服务器密码  MASTER_PASSWORD=&#39;123456&#39;,  # 主服务器端口  MASTER_PORT=3306,  # 主服务器 binlog 日志文件名,对应的 show master status 的 File  MASTER_LOG_FILE=&#39;mysql-bin.000002&#39;,  # 主服务器日志记录起点位置，对应的  show master status 的 Position  MASTER_LOG_POS=155,  # 连接重试次数  MASTER_CONNECT_RETRY=10;start slave;# 查看是否配置成功show slave status;Slave_IO_Running:Yes 此进程负责从服务器从主服务器上读取binlog 日志，并写入从服务器上的中继日志。 Slave_SQL_Running:Yes 此进程负责读取并且执行中继日志中的binlog日志， 注：以上两个都为yes则表明成功</code></pre><p>binlog 日志操作的常用命令</p><pre><code># 执行该命令，就会产生一个新的 log-bin 日志flush logs;# 清空所有的log-bin日志，并产生一个新的 log-bin 日志reset master;#查看最后（新）的一个 log-bin 日志show master status;</code></pre><h3 id="Laravel-读写分离"><a href="#Laravel-读写分离" class="headerlink" title="Laravel 读写分离"></a>Laravel 读写分离</h3><pre><code>        &#39;mysql&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;mysql&#39;,            &#39;read&#39; =&gt; [                &#39;host&#39; =&gt; &#39;192.168.1.6&#39;,                &#39;port&#39; =&gt; &#39;3307&#39;,                &#39;password&#39; =&gt; &#39;root&#39;            ],            &#39;write&#39; =&gt; [                &#39;host&#39; =&gt; &#39;192.168.1.6&#39;,                &#39;port&#39; =&gt; &#39;3306&#39;,                &#39;password&#39; =&gt; &#39;root&#39;            ],            &#39;url&#39; =&gt; env(&#39;DATABASE_URL&#39;),//            &#39;host&#39; =&gt; env(&#39;DB_HOST&#39;, &#39;127.0.0.1&#39;),//            &#39;port&#39; =&gt; env(&#39;DB_PORT&#39;, &#39;3306&#39;),            &#39;database&#39; =&gt; env(&#39;DB_DATABASE&#39;, &#39;forge&#39;),            &#39;username&#39; =&gt; env(&#39;DB_USERNAME&#39;, &#39;forge&#39;),//            &#39;password&#39; =&gt; env(&#39;DB_PASSWORD&#39;, &#39;&#39;),            &#39;unix_socket&#39; =&gt; env(&#39;DB_SOCKET&#39;, &#39;&#39;),            &#39;charset&#39; =&gt; &#39;utf8mb4&#39;,            &#39;collation&#39; =&gt; &#39;utf8mb4_unicode_ci&#39;,            &#39;prefix&#39; =&gt; &#39;&#39;,            &#39;prefix_indexes&#39; =&gt; true,            &#39;strict&#39; =&gt; true,            &#39;engine&#39; =&gt; null,            &#39;options&#39; =&gt; extension_loaded(&#39;pdo_mysql&#39;) ? array_filter([                PDO::MYSQL_ATTR_SSL_CA =&gt; env(&#39;MYSQL_ATTR_SSL_CA&#39;),            ]) : [],        ],</code></pre><blockquote><p>参考地址：</p><p><a href="https://blog.51cto.com/zhongliang/2152917" target="_blank" rel="noopener">https://blog.51cto.com/zhongliang/2152917</a></p><p><a href="https://www.cnblogs.com/chenhaoyu/p/10773988.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenhaoyu/p/10773988.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-OSS</title>
      <link href="/2020/01/16/Laravel-OSS/"/>
      <url>/2020/01/16/Laravel-OSS/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在项目当中，我们一般不会选择本地服务器存储访问资源，这样对于服务器来说的话也比较消耗资源。而第三方的存储服务器就可以帮我们解决这个问题。阿里云对象存储服务，简称 OSS，是一种面向海量数据规模的分布式存储服务，具有稳定、可靠、安全、低成本的特点，能够提供十一个九的数据可靠性。 OSS 提供与平台无关的 RESTful API 接口，您可以在互联网任何位置存储和访问。 OSS 的容量和处理能力弹性扩展，并提供多种存储类型供您选择，全面优化存储成本。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p> aliyuncs/<a href="https://packagist.org/packages/aliyuncs/oss-sdk-php" target="_blank" rel="noopener">oss-sdk-php</a></p><pre><code>$ composer require aliyuncs/oss-sdk-php</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>上传文件</p><pre><code>use OSS\OssClient;use OSS\Core\OssException;ry{     $oss = new OssClient(id,key,endpoint)    $result = $oss-&gt;uploadFile(bucket, 保存到 oss 的路径,上传文件的路径);} catch(OssException $e) {    ApiExceptionError(&#39;上传失败,请重新上传&#39;);}</code></pre><blockquote><p>未完代续</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-阿里云短信</title>
      <link href="/2020/01/16/Laravel-%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/"/>
      <url>/2020/01/16/Laravel-%E9%98%BF%E9%87%8C%E4%BA%91%E7%9F%AD%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在我们大多数项目当中，短信服务属于必不可少的一种功能。接口平台也是多如牛毛。今天要介绍的这个包，包含了大多知名平台的短信服务接入，也是我目前使用过最好的一个短信服务扩展包。开发者也是 Learnku 知名人物 “超哥”开发，在这里也安利一下超哥的 PHP 扩展包开发实战教程：<a href="https://learnku.com/courses/creating-package" target="_blank" rel="noopener">点我跳转</a></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>支持目前市面多家服务商</li><li>一套写法兼容所有平台</li><li>简单配置即可灵活增减服务商</li><li>内置多种服务商轮询策略、支持自定义轮询策略</li><li>统一的返回值格式，便于日志与监控</li><li>自动轮询选择可用的服务商</li><li>更多等你去发现与改进…</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://packagist.org/packages/overtrue/easy-sms" target="_blank" rel="noopener">EasySms</a> </p><pre><code>$ composer require overtrue/easy-sms</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>以下以阿里云为例子，我们可以在 config 目录当中新建一个 aliyun.php 配置文件，当然也可以直接使用。</p><pre><code>return [    &#39;aliyun&#39; =&gt; [        // HTTP 请求的超时时间（秒）        &#39;timeout&#39; =&gt; 5.0,        // 默认发送配置        &#39;default&#39; =&gt; [            // 网关调用策略，默认：顺序调用            &#39;strategy&#39; =&gt; \Overtrue\EasySms\Strategies\OrderStrategy::class,            // 默认可用的发送网关            &#39;gateways&#39; =&gt; [                &#39;aliyun&#39;,            ],        ],        // 可用的网关配置        &#39;gateways&#39; =&gt; [            &#39;errorlog&#39; =&gt; [                &#39;file&#39; =&gt; &#39;/tmp/easy-sms.log&#39;,            ],            &#39;aliyun&#39; =&gt; [                &#39;access_key_id&#39; =&gt; env(&#39;ACCESS_KEY_ID&#39;),                &#39;access_key_secret&#39; =&gt; env(&#39;ACCESS_KEY_SECRET&#39;),                &#39;sign_name&#39; =&gt; env(&#39;SIGN_NAME&#39;),// 阿里云的签名            ],        ],    ],    &#39;template&#39; =&gt; env(&#39;ALIYUN_TEMPLATE&#39;),// 阿里云的模板 ID];</code></pre><pre><code>use Overtrue\EasySms\EasySms;$easySms = new EasySms(config(&#39;aliyun.aliyun&#39;));$code = str_pad(random_int(1, 999999), 6, 0, STR_PAD_LEFT);try{    $result = $easySms-&gt;send(‘手机号码’, [        &#39;template&#39; =&gt; config(&#39;aliyun.template&#39;), // 模板 ID        &#39;data&#39; =&gt; [            &#39;number&#39; =&gt; $code // data 里面传递的就是你的模板变量，        ],    ],[&#39;aliyun&#39;]);     }catch (\GuzzleHttp\Exception\ClientException $exception){         $response = $exception-&gt;getResponse();         $result = json_decode($response-&gt;getBody()-&gt;getContents(), true);         return $this-&gt;response-&gt;errorInternal($result[&#39;msg&#39;]??&#39;短信发送异常&#39;);     }</code></pre><p>正常的流程情况下如果出现发送失败或者别的错误，可以找到包 overtrue/easy-sms/src/Gateways  下面，因为我目前使用的 阿里云那么我的就是 AliyunGateway.php 找到 send 在 result 返回之前打印一下就可以看到错误。这里的错误也是阿里云服务错误，而不是程序的错误。</p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年年度总结</title>
      <link href="/2020/01/14/2019%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/14/2019%E5%B9%B4%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>回顾 2019 展望 2020，时间总是在转眼即逝！当我们站在时间线前面的时候，总是对时间线后面的所有事情抱有很大的期望与规划，或者这的 ‘我们’ 应该用 ‘我’ 比较合适！我特别喜欢一句话，做过别后悔，错过别回头！然而真实的我总是实在跟别人述说我的 “后悔的事情”，也许是心智未成熟吧，但是我还是喜欢有什么就说出来憋着难受！每过一段时间，我总是喜欢停下来整理一下所有前面的事情，写项目也是如此总是希望自己的代码能够达到心中理想的样子，但是事与愿违比较多那么一些，总体上来说还算及格。我也喜欢总是想把自己知识整理完善，但总是发现时间不够用（当然这也是自己说给自己的借口，时间挤挤还是有的 ）希望 2020 能自我改变一哈吧，实现自我的进化！</p><p><img src="https://i.loli.net/2020/01/15/QwPnoZreAbYaV7K.jpg" alt="timg.jpeg"></p><h3 id="宁波篇"><a href="#宁波篇" class="headerlink" title="宁波篇"></a>宁波篇</h3><p>19 年离开宁波公司回到成都，最开始我老汉和我妈特别不愿意。首先说一哈，我不是妈宝男，只是我从小就去的宁波读书生活，朋友亲戚基本都在宁波，一直跟着他们重来没有离开过他们，所以对于我不在去宁波跟他们一起特别不放心。最后我放出了终极大招他们才愿意我回来，我说回来后一定找到个女朋友，他们才愿意。（然而事实确是连个女的微信都没，在此我要强行甩一下锅，不是不想找是圈子太小没办法呀！）</p><p>希韵一个做钢琴教育类 App 软件开发的团队，一个非常不错的一个团队，公司的组织架构完整，团队气氛也是非常的好。以下是 2019 年年度团队动漫自画像。</p><p><img src="https://i.loli.net/2020/01/16/f45yHsDKAhJzRia.jpg" alt="img.jpeg"></p><p>我还依稀记得刚去面试，主管大哥很看好我，在面试完成后送我离开时跟我也分享了一些他的经历（可能公司基本都是宁波本地人，而他是贵州人而我是四川人的原因吧），可惜最后让他失望了。年轻嘛，总是有些时候犯混。也感谢当初辉哥和主管大哥选择了我，工作之后我问过辉哥为啥选我，我已经记不清他当时怎么说的了，我想估计是我的诚实吧。我入希韵时简历完全真实，没有任何参假，没工作经验，没项目经验，唯一有的是我离开学校那天起就一直从事计算机这块，转开发前就从事运维这块（当然是最低级的运维或者简单说修电脑的只是负责厂区）在现今的大环境下敢写真实的简历也是需要一定的勇气的，又没学历又没项目经验。</p><p>人生总是这样，生命当中总是会有那么几个站，你会在哪里停留，但是最终还是会重新扬帆启航！</p><p>告别了成长的第一站，我驶向了我的第二站，成都，成都篇启航！</p><p><img src="https://i.loli.net/2019/09/03/RWBTwtkD2MjPavh.jpg" alt></p><h3 id="成都篇-一"><a href="#成都篇-一" class="headerlink" title="成都篇 一"></a>成都篇 一</h3><p>四川玄通科技有限公司，面试我的是罗哥，应该算不上面试而是算讲解知识。没记错的话大概面试了一个多小时，很多问题不知道，罗哥跟大多数面试管不一样，不会因为你不会而有点别的样子(具体啥样子感觉就是有点看不起吧)，不知道或者认知错误的他都会一一的给你讲解。通过那一次面试我还学到了不少东西，影像最深的是他把 MySQL 索引这个东西给我讲解的大概明白了，以前基本都是模糊的认知。这样的面试才有意义，有收获！不像一些眼睛在天上的人上来就问（处理过千万级数据没有啊，高并发处理过吗）不怕您笑，现在做过三个项目别说千万级别了 10 W都没处理过。这样问的往往是那种几个人的公司，有时候真忍不住想问贵公司都这样牛逼了，团队咋这点人呢？没办法呀，本人眼界知识面太低，见笑见笑。</p><p>面试结束后，就说等待通知，我一想肯定没戏啊。回答的也不好，基本没了，就去下一家公司面试了。结果下一家公司给我气的呀，是个培训结构，为了约好的时间不迟到我还专门 打车过去的，结果是个培训机构。最后想了想压根没投递他们公司简历，我是手机收到短信就去了也没太注意，我好奇的是手机号码是如何被他们知道的，都是套路呀。</p><p>过了二天还是三天，收到了行政的通知可以入职玄通了。当时很高兴，因为这哈有大佬带了，特别高兴。</p><p>玄通呢，做的项目就是区块链的东西，说是区块链具体有没有上链我也没搞清楚，用的也就是火币的接口。从入职开始，有啥不懂的就问罗哥，反正他也不会烦你不懂问他，相反罗哥是一个特别喜欢帮助人的人，只要不懂的问他都会耐心的解答。从代码的语法，到一些东西使用和原理都会一一讲解，反正我非常喜欢跟着罗哥，成长快呀！</p><p>在玄通的日子每天就这样工作着，学习着，没事情的时候大家就一起吹吹壳子，开开车。好不欢乐！</p><p>可惜好景不长，在项目第二个版本开始的时候，8 月份的某一天清晨。老板先是把行政，罗哥和前端叫进办公室，我一哈就觉得不对了。因为那段时间罗哥一直挂嘴边的就是公司快倒闭了，结果真的倒闭了！！！他们先单独聊了后，老板叫所有人进去了，公司正式宣布倒闭！可气的是到现在还有一点工钱没给，搞得我没事给老板发几朵花。不舍玄通，无奈告别！开启第二篇章！</p><p><img src="https://i.loli.net/2020/01/16/s2EHUQRVcNAgMx1.jpg" alt="96c6035bd38a43c3bc532447a7292ee2.jpeg"></p><h3 id="成都篇-二"><a href="#成都篇-二" class="headerlink" title="成都篇 二"></a>成都篇 二</h3><p>我易网络科技有限公司，面试我的是公司负责项目的人。面试不算太久吧，好像 10 分钟的样子，也是等待通知。心想肯定没了，才那么几分钟。结果在我第二天去铂涛面试的路上收到了入职通知，面试铂涛是二个人一起面试，那次面试把我搞得紧张死了。大概面试了 30 多分钟吧，也是等待通知。面试完成后，就回家准备第二天入职我易了。</p><p>入职我易当天也收到了铂涛的入职邀请，出于已经入职我易和不会 YII 谢绝了铂涛正式开始了，我易的旅途。</p><p>我易跟玄通基本一样，也是做虚拟币交易的公司，也是没有上链都是自我数据处理（不过目前的是版本一，后期估计是会上链操作）。刚开始都是老套路，熟悉公司先目前的项目代码。前面基本也没什么事情，基本上都在原先的项目上面各种修改。其实我是拒绝二开的，比较每个人的风格不一，而且还需要去读懂原有的代码就更难受了。在修改过程中，我们也经常喷方维写的代码垃圾（结果自己写后发现自己的根本没法跟方维的比），终于在 11 月份，项目开始了重构。我们整个团队开启了奋战模式，几乎这几个月来每一天都在加班奋战赶项目。1月10号在连续奋战30多个小时后，第一个版本正式上线。虽然存在很多问题，但也正式上线了。到此三篇结束，2019 年的也即将结束。</p><p><img src="https://i.loli.net/2020/01/16/4dSzbiC5YmOa7jg.jpg" alt="center.jpeg"></p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><p>1、PHP 深入学习</p><p>2、研究 Larave 框架</p><p>3、学习 Go</p><p>4、学习 Flutter</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、拖延症比较严重</p><p>2、执行能力，有待提高</p><p>3、心性有待提高</p><blockquote><p>祝愿 2020 更好，道别 2019 。2020 加油吧！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 2019年年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019年年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-记录一次优化</title>
      <link href="/2019/12/19/Laravel-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96/"/>
      <url>/2019/12/19/Laravel-%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>这是一个非常帅气的摘要，非常非常的帅。对！是的！我不知道说什么了，就先这样吧！别问我为什么，因为我就是这么随便的人呀！</p><h3 id="去除没必要的中间件"><a href="#去除没必要的中间件" class="headerlink" title="去除没必要的中间件"></a>去除没必要的中间件</h3><p>当然，因个人项目而定！Laravel 的中间件全部定义在 <code>app\Http\Kernel.php</code> 当中。</p><pre><code>### 全局中间件    /**     * The application&#39;s global HTTP middleware stack.     * 应用程序的全局HTTP中间件堆栈     * These middleware are run during every request to your application.     *这些中间件在对您的应用程序的每次请求期间运行     * @var array     */    protected $middleware = [        # 关于设置信任代理有关的中间件        \App\Http\Middleware\TrustProxies::class,        # Laravel 开启 维护模式        \App\Http\Middleware\CheckForMaintenanceMode::class,        # 验证 POST 数据大小 有关        \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class,        # 前后空白字符清理        \App\Http\Middleware\TrimStrings::class,        # 会把请求参数空字符串自动转为 null        \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,    ];</code></pre><p>去除所有的中间件，效率的提升大概在 8 ms 左右。注意根据自己公司项目需求来定中间件，不需要的可以注释掉。</p><h3 id="开启-Opcode"><a href="#开启-Opcode" class="headerlink" title="开启 Opcode"></a>开启 Opcode</h3>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-XSS 攻击过滤</title>
      <link href="/2019/12/16/Laravel-Xss-%E6%94%BB%E5%87%BB%E8%BF%87%E6%BB%A4/"/>
      <url>/2019/12/16/Laravel-Xss-%E6%94%BB%E5%87%BB%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>XSS 攻击，XSS 是跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。它总是让我们头痛，目前还不是很了解，毕竟前端的知识欠缺，看过一篇文章说“越了解 XSS 越不知道该如何去防范”。目前来说所认知的 XSS 就是前端的 JS 搞事情，那么好在数据处理时候我们过滤掉黑名单的前端标记。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://packagist.org/packages/mews/purifier" target="_blank" rel="noopener">mews/purifier</a></p><pre><code>composer require mews/purifier</code></pre><p>再次提示一次，在 Laravel 5.5 版本之后不需要在添加服务提供者，都是自动发现。</p><h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><pre><code>$ php artisan vendor:publish --provider=&quot;Mews\Purifier\PurifierServiceProvider&quot;</code></pre><p>此时 <code>config/purifier.php</code> 就会出现在你的 config 目录当中。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用 purifier 非常的简单</p><pre><code>clean(request()-&gt;input(&#39;content&#39;))</code></pre><p>注意：我们可以使用的标记在 <code>config/purifier.php</code> HTML.Allowed 配置当中</p><pre><code># 以下是默认的允许的标记&#39;HTML.Allowed&#39;             =&gt; &#39;div,b,strong,i,em,u,a[href|title],ul,ol,li,p[style],br,span[style],img[width|height|alt|src]&#39;,</code></pre><p>在我们使用 clean 过滤我们的参数之后，默认自动段落的也就是说数据会自动加上 “ P “  标记</p><p><img src="https://i.loli.net/2019/12/16/S1ZVk3yHJfFig9E.png" alt></p><p>如果不需要加上 “ P “  标记，那么我们需要把配置文件当中的 AutoFormat.AutoParagraph 改为 false</p><pre><code>&#39;AutoFormat.AutoParagraph&#39; =&gt; false,</code></pre><p><img src="https://i.loli.net/2019/12/16/bGkTYjigILOsC4d.png" alt></p><p>回到最开始，我们在 HTML.Allowed 允许的情况下，那么我们 HTML 标记就不会被过滤掉</p><p><img src="https://i.loli.net/2019/12/16/oK68RCm3THeYdAS.png" alt></p><h3 id="使用中间件全局过滤"><a href="#使用中间件全局过滤" class="headerlink" title="使用中间件全局过滤"></a>使用中间件全局过滤</h3><pre><code># 创建中间件php artisan make:middleware ApiXssCleanpublic function handle($request, Closure $next){    $input = $request-&gt;all();    array_walk_recursive($input,function(&amp;$input) {        $input = is_string($input) ? trim(clean($input)) : $input;    });    $request-&gt;merge($input);    return $next($request);}</code></pre><p><img src="https://i.loli.net/2019/12/16/QXW8ULvFlen7MOx.png" alt></p><h3 id="使用-PHP-函数-暴力过滤"><a href="#使用-PHP-函数-暴力过滤" class="headerlink" title="使用 PHP 函数 暴力过滤"></a>使用 PHP 函数 暴力过滤</h3><p>strip_tags — 从字符串中去除 HTML 和 PHP 标记</p><pre><code># 效果与上面一致$input = $request-&gt;all();array_walk_recursive($input,function(&amp;$input) {    $input = strip_tags($input);});$request-&gt;merge($input);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-Goog验证</title>
      <link href="/2019/11/18/Laravel-Goog%E9%AA%8C%E8%AF%81/"/>
      <url>/2019/11/18/Laravel-Goog%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>对于一些项目敏感操作来说验证用户都是属于必备的一个环节，当然验证的方式很多，确实很多！Google 验证，在我看来是验证当中的一种不错的选择，毕竟一次操作终身可行，而且 Google 自身就帮我们处理好了验证码有效期。（每30秒刷新一次），签名算法安全可靠！Laravel 做为 PHP 目前使用率最高的框架，当然也有他的 Google 验证扩展包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://packagist.org/packages/pragmarx/" target="_blank" rel="noopener">pragmarx/</a>google2fa-laravel</p><pre><code># 扩展 Imagick 开启composer require pragmarx/google2fa-laravel</code></pre><p><a href="https://packagist.org/packages/bacon/" target="_blank" rel="noopener">bacon/</a>bacon-qr-code</p><pre><code># 扩展 iconv 开启# dasprid/enumcomposer require bacon/bacon-qr-code</code></pre><h4 id="安装-Imagick-扩展"><a href="#安装-Imagick-扩展" class="headerlink" title="安装 Imagick 扩展"></a>安装 Imagick 扩展</h4><pre><code>apt-get install imagemagickconvert -version 使用这个命令检测是否安装成功，如果成功的话会有imagemagick版本号。apt-get install libmagickwand-dev</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>生成 Google2FA 配置文件，文件存在位置 config/google2fa.php，命令如下：</p><pre><code>php artisan vendor:publish --provider=&quot;PragmaRX\Google2FALaravel\ServiceProvider&quot;</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>生成 Secret Key</p><pre><code>use PragmaRX\Google2FA\Google2FA;$google2fa = new Google2FA();$secretKey = $google2fa-&gt;generateSecretKey(64);# 这里的 Key 就是我们需要验证的 Key</code></pre><p>获取二维码地址</p><pre><code>$company = &#39;&#39;; // 公司名称$holder = &#39;&#39;; // 用户标示，可以是邮箱或者名称等$qrcodeUrl = $google2fa-&gt;getQRCodeUrl($company, $holder, $secretKey);</code></pre><p>生成二维码图片</p><pre><code>// 图片路径$filePath = sha1($secretKey) .&#39;.png&#39;;// 生成图片$renderer = new ImageRenderer(   new RendererStyle(200),   new ImagickImageBackEnd());$writer = new Writer($renderer);$writer-&gt;writeFile($qrcodeUrl, $filePath);</code></pre><p><img src="https://i.loli.net/2019/11/18/hTlsNIDrVp5qmFz.png" alt></p><p>最后，通过使用 Google Authenticator 应用程序来扫描二维码，扫描完毕之后，就会生成一组 6 位的数字密码。</p><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><pre><code>$google2fa = new Google2FA();$verify = $google2fa-&gt;verifyKey($secretKey, $request-&gt;input(&#39;code&#39;));if ($verify) {    return true;  // 验证成功}return false;</code></pre><blockquote><p>参考地址：</p><p><a href="https://www.raymondwu.net/2018/05/14/Laravel-利用Google2FA实现双因子认证/" target="_blank" rel="noopener">https://www.raymondwu.net/2018/05/14/Laravel-%E5%88%A9%E7%94%A8Google2FA%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%9B%A0%E5%AD%90%E8%AE%A4%E8%AF%81/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-RSA加密解密</title>
      <link href="/2019/11/14/PHP-RSA%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/2019/11/14/PHP-RSA%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>在目前的大环境下，我们一般的项目都是属于前后端分离的操作。数据安全就是让我们非常头痛的一件事情。</p></blockquote><h3 id="生成公钥私钥"><a href="#生成公钥私钥" class="headerlink" title="生成公钥私钥"></a>生成公钥私钥</h3><p>Linux 系统都自带了openssl，windows 可能需要安装 openssl 生成工具</p><pre><code>// 第一步：生成私钥，这里我们指定私钥的长度为1024, 长度越长，加解密消耗的时间越长openssl genrsa -out rsa_private_key.pem 1024// 第二步：根据私钥生成对应的公钥openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pub// 第三步：私钥转化成pkcs8格式，【这一步非必须，只是程序解析起来方便】openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem</code></pre><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>RSA 只能加密最长 117 位的数据</p><pre><code>$data = &#39;123&#39;;$data = json_encode($data);$Split = str_split($data, 64);ForEach($Split as $Part){    openssl_private_encrypt($Part,$PartialData,$privateKey);//服务器公钥加密    $t = strlen($PartialData);    $encParam_encrypted .= $PartialData;}$data = base64_encode($encParam_encrypted);</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-深入</title>
      <link href="/2019/11/14/Laravel-%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/11/14/Laravel-%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>工欲善其事必先利其器，在现今的环境下各种框架多如牛毛。Laravel 是我接触过目前来说最好用的框架（ps：目前就用过 Laravel 和 Thinkphp = =），所以对于 Laravel 是非常的喜爱 。Laravel 在国内的生态也是非常的好，因为在国内有个专业的 Laravel 论坛非常的活跃每天都各式各样的问题讨论研究，文档也是跟着官方文档翻译而来，在此我得特别跟您安利一波  <a href="https://learnku.com/laravel" target="_blank" rel="noopener">点我跳转</a>。Laravel 各种扩展包也是非常多，各类开源的项目也是多如牛毛，官方也是对 Laravel 的维护与开发非常给力，所以我非常喜欢用 Laravel。当然用也是简单的会用了，目前就想着研究一下框架的各种套路技术，一起共勉吧！</p><blockquote><p>最近很忙很忙，等有时间，上传学习笔记</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-定时任务</title>
      <link href="/2019/10/24/Laravel-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/10/24/Laravel-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在我们项目当中，有时候需要定时去处理一些特定的业务。过去，你可能需要在服务器上为每一个调度任务去创建 Cron 入口。但是这种方式很快会变得不友好，因为这些任务调度不在源代码中，并且你每次都需要通过 SSH 链接登录到服务器中才能增加 Cron 入口。</p><p>Laravel 命令行调度器允许你在 Laravel 中对命令调度进行清晰流畅的定义。且使用这个任务调度器时，你只需要在你的服务器上创建单个 Cron 入口。你的任务调度在 <code>app/Console/Kernel.php</code> 的 <code>schedule</code> 方法中进行定义。</p><h3 id="Kernel-php"><a href="#Kernel-php" class="headerlink" title="Kernel.php"></a>Kernel.php</h3><p>不管我们是使用定时任务或者其他需要终端执行的程序，在 Laravel 当中都要在 <code>app\console\kernel.php</code>当中的 commands 引入我们自定义的 artisan 命令类，schedule 执行我们的定时任务。</p><pre><code># 加载 artisan 自定义命令类protected $commands = [        // 引入自定义的终端命令类    ];    # 执行 定时任务    protected function schedule(Schedule $schedule){    # 简单使用    $schedule-&gt;call(function(){        Log::info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; request()-&gt;path()]);    })-&gt;daily();    $schedule-&gt;call(&#39;App\Services\xxxService@index&#39;)-&gt;everyMinute();    # 执行 command    $schedule-&gt;command(&#39;order:start&#39;)              -&gt;hourly();}# 注册 artisan 执行的命令，对应的也就是我们 routes 下面的 console.phpprotected function commands(){    $this-&gt;load(__DIR__.&#39;/Commands&#39;);    require base_path(&#39;routes/console.php&#39;);}</code></pre><blockquote><p>在 Laravel 5.5 版本以后，无需在 commands 引入。</p></blockquote><h3 id="创建-Command"><a href="#创建-Command" class="headerlink" title="创建 Command"></a>创建 Command</h3><pre><code>php artisan make:command AddOrderCount</code></pre><p>当创建完成 command 之后，按自己需求修改 command</p><pre><code>class OrderCount extends Command{    // 执行的 artisan 命令    protected $signature = &#39;order:start&#39;;    // artisan 命令的描述    protected $description = &#39;day order count data&#39;;    public function __construct()    {        parent::__construct();    }    // 这里即可执行 业务逻辑的处理    public function handle()    {        // 要执行的 处理业务逻辑    }}</code></pre><h3 id="执行-Crontab"><a href="#执行-Crontab" class="headerlink" title="执行 Crontab"></a>执行 Crontab</h3><pre><code>1、创建 crontab 执行的文件echo &quot;* * * * * /usr/local/bin/php /var/www/html/vpay/artisan schedule:run &gt;&gt; /dev/null 2&gt;&amp;1&quot; &gt; order.txt2、添加到 crontab 当中crontab order.txt3、开启 crontabcrontabl -l 4、关闭 crontab 全部清除crontabl -r</code></pre><blockquote><p>在 Linux 创建一个 Crontab 执行文件时，所有的执行命令加上绝对路径！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Guzzle</title>
      <link href="/2019/10/15/curl%E5%92%8CGuzzle/"/>
      <url>/2019/10/15/curl%E5%92%8CGuzzle/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>PHP 支持 Daniel Stenberg 创建的 libcurl 库，能够连接通讯各种服务器、使用各种协议。libcurl 目前支持的协议有 http、https、ftp、gopher、telnet、dict、file、ldap。 libcurl 同时支持 HTTPS 证书、HTTP POST、HTTP PUT、 FTP 上传(也能通过 PHP 的 FTP 扩展完成)、HTTP 基于表单的上传、代理、cookies、用户名+密码的认证。</p><h3 id="Curl-访问本地-hosts"><a href="#Curl-访问本地-hosts" class="headerlink" title="Curl 访问本地 hosts"></a>Curl 访问本地 hosts</h3><p>今天遇到一个问题，curl 无法访问本地的 hosts，解决方案如下。正常情况下 它不走 hosts，所以不会生效！！！</p><pre><code>curl_setopt($ch, CURLOPT_URL, &#39;http://127.0.0.1/v1/order/create&#39;);curl_setopt($ch, CURLOPT_HTTPHEADER, array(&#39;Host:open.pay.com&#39;));curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, &#39;POST&#39;);curl_setopt($ch, CURLOPT_POSTFIELDS, $params);$data = curl_exec($ch); // 运行curlcurl_close($ch);</code></pre><pre><code>curl_setopt($ch, CURLOPT_URL, &#39;http://127.0.0.1/v1/order/create&#39;);curl_setopt($ch, CURLOPT_HTTPHEADER, array(&#39;Host:open.pay.com&#39;));# 对应 hosts127.0.0.1 open.pay.com</code></pre><h3 id="Guzzle"><a href="#Guzzle" class="headerlink" title="Guzzle"></a>Guzzle</h3><p>Guzzle 是一个 PHP 的 HTTP 客户端，用来轻而易举地发送请求，并集成到我们的 WEB 服务上。</p><ul><li>接口简单：构建查询语句、POST 请求、分流上传下载大文件、使用 HTTP cookies、上传 JSON 数据等等。</li><li>发送同步或异步的请求均使用相同的接口。</li><li>使用 PSR-7 接口来请求、响应、分流，允许你使用其他兼容的 PSR-7 类库与 Guzzle 共同开发。</li><li>抽象了底层的 HTTP 传输，允许你改变环境以及其他的代码，如：对 cURL 与 PHP 的流或 socket 并非重度依赖，非阻塞事件循环。</li><li>中间件系统允许你创建构成客户端行为。</li></ul><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol><li>PHP 5.5.0</li><li>使用 PHP 的流， <code>allow_url_fopen</code> 必须在 php.ini 中启用。</li><li>要使用 cURL，你必须已经有版本 cURL &gt;= 7.19.4，并且编译了OpenSSL 与 zlib。</li></ol><blockquote><p>如果没有安装 cURL，Guzzle 处理 HTTP 请求的时候不再使用 cURL，而是使用 PHP 流处理，或者你也可以提供自己的发送 HTTP 请求的处理方式。</p></blockquote><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code>composer require guzzlehttp/guzzle</code></pre><h4 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h4><pre><code># 创建客户端 默认请求use GuzzleHttp\Client;$client = new GuzzleHttp\Client([&#39;base_uri&#39; =&gt; &#39;https://www.php.com/api/&#39;，&#39;timeout&#39;  =&gt; 2.0]);# 发送请求到 https://www.php.com/api/test$response = $client-&gt;request(&#39;GET&#39;, &#39;test&#39;);# 表单请求$response = $client-&gt;request(&#39;POST&#39;, &#39;http://httpbin.org/post&#39;, [    &#39;form_params&#39; =&gt; [        &#39;field_name&#39; =&gt; &#39;abc&#39;,        &#39;other_field&#39; =&gt; &#39;123&#39;,        &#39;nested_field&#39; =&gt; [            &#39;nested&#39; =&gt; &#39;hello&#39;        ]    ]]);</code></pre><blockquote><p>官方文档：</p><p><a href="https://guzzle-cn.readthedocs.io/zh_CN/latest/quickstart.html" target="_blank" rel="noopener">https://guzzle-cn.readthedocs.io/zh_CN/latest/quickstart.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-本地语言包</title>
      <link href="/2019/10/11/Laravel-%E6%9C%AC%E5%9C%B0%E8%AF%AD%E8%A8%80%E5%8C%85/"/>
      <url>/2019/10/11/Laravel-%E6%9C%AC%E5%9C%B0%E8%AF%AD%E8%A8%80%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Laravel 自身的语言包为英文，我们本地化开发都希望为中文，当然也有不需要中文的这个看自己项目的选择行来说，我做的项目一般都是本地化。所以本地化是不可缺少的一块。今天的主角就是 [<a href="https://packagist.org/packages/caouecs/" target="_blank" rel="noopener">caouecs/</a><a href="https://packagist.org/packages/caouecs/laravel-lang#dev-master" target="_blank" rel="noopener">laravel-lang</a>] ,支持 N 多国家语言包。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ composer require caouecs/laravel-lang</code></pre><blockquote><p>请根据自己项目使用的 Laravel 版本选择分支，不同的分支对应 Laravel 不同的版本。</p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>laravel-lang 使用非常简单，在我们 Composer 安装好这个扩展包以后，在 verdor 依赖包目录当中找到 <code>caouecs/laravel-lang</code>把里面的 zh-CN 复制到 <code>resources/lang</code>下面。修改 <code>config/app.php</code></p><pre><code>&#39;locale&#39; =&gt; &#39;zh-CN&#39;,</code></pre><p>到此完成了 Laravel 语言包的替换，现在使用就是本地化了（如：表单验证），当然有无法替换的地方可以自行去修改语言包。</p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-Fractal</title>
      <link href="/2019/09/26/Laravel%E4%B9%8BFractal/"/>
      <url>/2019/09/26/Laravel%E4%B9%8BFractal/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们想返回的数据做格式化一般情况下我们就在逻辑层当中操作，这样复用性很差基本就是复制粘贴。使用了  Fractal 之后我们就可以统一一些数据返回的规范，复用性非常高。</p><p><img src="https://i.loli.net/2019/09/26/Dy7bAWSHLeExzot.png" alt></p><p><strong>PHP 领域广受欢迎的 API 数据输出格式转换器</strong></p><ul><li>支持 <code>单个对象</code> 或者 <code>集合对象</code> 的格式化</li><li>通过 Fractal Transformer 显式修饰对象的数据输出，将复杂数据转为 ajax/restful</li><li>额外特性<ul><li>关联数据的<code>Include</code>动态加载</li><li>数据载荷转换到各种协议格式：<code>JSON</code>、<code>DataArray</code>、<code>HAL</code>等等</li></ul></li><li>友好的和<code>DingoApi</code>无缝结合</li></ul><p><strong>对于 WEB 站来说</strong></p><ul><li>不建议过多进行数据格式化，直接输出完整对象，尽量用对象来替代数组</li><li>特别的字段值计算可以封装为对象的方法</li></ul><h3 id="原生使用"><a href="#原生使用" class="headerlink" title="原生使用"></a><strong>原生使用</strong></h3><pre><code>class MyTransformer extends League\Fractal\TransformerAbstract{    # normalize主逻辑    public function transform($object){        return [            &#39;id&#39; =&gt; $object-&gt;id,            &#39;name&#39; =&gt; $object-&gt;name,        ];    }    ## include特性 ##    ## 使用前需要检测include参数：$manager-&gt;parseIncludes($_GET[&#39;include&#39;]);    protected $defaultIncludes = []; #声明需要默认include的资源    protected $availableIncludes = [tag]; #声明可选include资源    public function includeTag($object){        $tag = $object-&gt;tag;        return $this-&gt;item($tag, new TagTransformer);  #包含单对象        #return $this-&gt;collection($tags, new TagTransformer); #包含集合对象    }}$itemResource = new \Fractal\Resource\Item(    $object,    League\Fractal\TransformerAbstract $myTransformer);$collectionResource = new \Fractal\Resource\Collection(    $objects,    League\Fractal\TransformerAbstract $myTransformer);$manager = new League\Fractal\Manager();$manager = $manager-&gt;createData($itemResource|$collectionResource)-&gt;toArray|toJson(); #transformer转换数据# 可以进一步使用serializer在toArray()输出前调整数据结构</code></pre><h3 id="Laravel-下-Fractal-使用"><a href="#Laravel-下-Fractal-使用" class="headerlink" title="Laravel 下 Fractal 使用"></a>Laravel 下 Fractal 使用</h3><p>1、Composer 引入</p><pre><code>composer require league/fractal</code></pre><p>2、创建自定义数据处理文件</p><pre><code>&lt;?phpnamespace App\Http\DataResponse;use App\Http\Model\User;use League\Fractal\TransformerAbstract;class UserDataResponse extends TransformerAbstract{   public function transform(User $user)   {       return [           &#39;id&#39; =&gt; $user-&gt;id,           &#39;mobile&#39; =&gt; $user-&gt;mobile,           &#39;nickname&#39; =&gt; $user-&gt;nickname,           &#39;avatar&#39; =&gt; $user-&gt;avatar,           &#39;updated_at&#39; =&gt; (string)$user-&gt;updated_at,           &#39;created_at&#39; =&gt; (string)$user-&gt;created_at,       ];   }}</code></pre><p>3、集合对象序列化</p><pre><code> # 需要 use  use App\Http\DataResponse\UserDataResponse; use League\Fractal\Manager; use League\Fractal\Resource\Collection; # 正常使用 $fractal = new Manager(); $users = new collection(User::all(), new UserDataResponse()); $users = $fractal-&gt;createData($users)-&gt;toArray(); return $users;</code></pre><p>4、单个对象序列化</p><pre><code> # 需要 use  use App\Http\DataResponse\UserDataResponse; use League\Fractal\Manager; use League\Fractal\Resource\Item; # 正常使用 $fractal = new Manager(); $users = new Item(auth()-&gt;user(), new UserDataResponse()); $users = $fractal-&gt;createData($users)-&gt;toArray(); return $users;</code></pre><blockquote><p>参考地址：</p><p><a href="https://my.oschina.net/u/2400083/blog/988715" target="_blank" rel="noopener">https://my.oschina.net/u/2400083/blog/988715</a></p><p><a href="https://zhuanlan.zhihu.com/p/25554084" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25554084</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-消息通知与消息推送</title>
      <link href="/2019/09/26/Laravel%E4%B9%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
      <url>/2019/09/26/Laravel%E4%B9%8B%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>消息推送是 APP 开发中非常重要的功能，可以让不在前台运行的 APP，及时进行消息通知，应用于新闻内容、促销活动、产品信息、版本更新提醒、订单状态提醒等多种场景。</p><blockquote><p>学习当中。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-消息通知与消息推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swoole</title>
      <link href="/2019/09/26/swoole/"/>
      <url>/2019/09/26/swoole/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>使 PHP 开发人员可以编写高性能的异步并发 TCP、UDP、Unix Socket、HTTP，WebSocket 服务。Swoole 可以广泛应用于互联网、移动通信、企业软件、云计算、网络游戏、物联网（IOT）、车联网、智能家居等领域。 使用 PHP + Swoole 作为网络通信框架，可以使企业 IT 研发团队的效率大大提升，更加专注于开发创新产品。</p><blockquote><p>Swoole 使用纯 C 语言编写，提供了 PHP 语言的异步多线程服务器，异步 TCP/UDP 网络客户端，异步 MySQL，异步 Redis，数据库连接池，AsyncTask，消息队列，毫秒定时器，异步文件读写，异步DNS查询。 Swoole内置了Http/WebSocket服务器端/客户端、Http2.0服务器端。</p><p>除了异步 IO 的支持之外，Swoole 为 PHP 多进程的模式设计了多个并发数据结构和IPC通信机制，可以大大简化多进程并发编程的工作。其中包括了并发原子计数器，并发 HashTable，Channel，Lock，进程间通信IPC等丰富的功能特性。</p><p>Swoole2.0 支持了类似 Go 语言的协程，可以使用完全同步的代码实现异步程序。PHP 代码无需额外增加任何关键词，底层自动进行协程调度，实现异步。</p></blockquote><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>在学习 Swoole 的时候，经常出现的词汇：同步，异步，阻塞，非阻塞。</p><h4 id="什么是-I-O-编程"><a href="#什么是-I-O-编程" class="headerlink" title="什么是 I/O  编程"></a>什么是 I/O  编程</h4><p>IO 在计算机当中指 Input\Output ，也就是所说的<code>输入与输出</code>。由于程序和运行时数据是在内存中驻留，由 CPU 这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，需要 IO 接口。</p><p>比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络 IO 获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的 HTML，这个动作是往外发数据，叫 Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫 Input。所以，通常，程序完成 IO 操作会有 Input 和 Output 两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有 Input 操作，反过来，把数据写到磁盘文件里，就只是一个 Output 操作。</p><p>IO 编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，<strong>但是只能单向流动</strong>。Input  Stream 就是数据从外面（磁盘、网络）流进内存，Output Stream 就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p><blockquote><p>小结一下，程序运行是依靠 CPU 和内存来进行的，IO 操作是相对于内存而言的，从外部设备进入内存就叫 Input ,反之从内存输出到外部设备就叫 Output 。<br>IO 按照设备来分的话，分为两种，其一是网络 IO ，也就是通过网络进行数据的拉取和输出。还有一种是磁盘 IO ,主要是对磁盘进行读写工作。</p><p>PHP 当中的 IO 编程也就是文件操作了，而且 PHP 不支持非阻塞。</p></blockquote><h4 id="同步，异步"><a href="#同步，异步" class="headerlink" title="同步，异步"></a>同步，异步</h4><p>由于 CPU 和内存的速度远远高于外设的速度，所以，在 IO 编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把 100M 的数据写入磁盘，CPU 输出 100M 的数据只需要 0.01 秒，可是磁盘要接收这 100M 数据可能需要 10 秒，怎么办呢？有两种办法：</p><p>第一种是 CPU 等着，也就是程序暂停执行后续代码，等 100M 的数据在 10 秒后写入磁盘，再接着往下执行，这种模式称为同步 IO</p><p>第二种是 CPU 不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步 IO </p><h4 id="阻塞，非阻塞"><a href="#阻塞，非阻塞" class="headerlink" title="阻塞，非阻塞"></a>阻塞，非阻塞</h4><p>比较模糊的概念，目前觉得跟 异步和同步一样，只是异步和同步需要回调使用，而他他们不需要。整理理解当中。。。</p><blockquote><p>说到磁盘还的分享下：</p><p>读磁盘太慢,慢的 cpu 等不了.于是就有了 cache(缓存).</p><p>写磁盘太慢,慢的 cpu 受不了,于是就有了 buffer(缓冲)</p></blockquote><h4 id="多进程-多线程"><a href="#多进程-多线程" class="headerlink" title="多进程/多线程"></a>多进程/多线程</h4><p>概念非常模糊，理解当中。。。</p><h3 id="Docker-配置-Swoole"><a href="#Docker-配置-Swoole" class="headerlink" title="Docker 配置 Swoole"></a>Docker 配置 Swoole</h3><p>配置多端口，这样才可以访问 Swoole 不然无法访问，注意刚配置 PHPFPM 的时候只配置了一个端口 一般为：9000 ，且这个端口已经被 FPM 绑定，所以我们在创建容器时需要指定二个端口一个给 FPM 一个 Swoole</p><pre><code>docker run --name swoole -p 9000:9000 -p 9500:9500 --link mysql:mysql -v /home/golang/docker/web/:/var/www/html -v /home/golang/docker/php/www.conf:/usr/local/etc/php-fpm.d/www.conf -v /home/golang/docker/php/php.ini:/usr/local/etc/php/php.ini -v /home/golang/docker/php/php-fpm.conf:/usr/local/etc/php-fpm.conf -d php:fpm</code></pre><h3 id="创建-TCP-服务器"><a href="#创建-TCP-服务器" class="headerlink" title="创建 TCP 服务器"></a>创建 TCP 服务器</h3><pre><code>&lt;?php//创建Server对象，监听 9500 端口$serv = new Swoole\Server(&quot;0.0.0.0&quot;, 9500); // 用于设置运行时的服务器各项参数$serv-&gt;set(    [        &#39;worker_num&#39; =&gt; 4,//worke进程数量，最好为本身机器CPU核数的 1-4倍，        &#39;max_request&#39; =&gt; 1000,//此参数表示worker进程在处理完1000次请求后结束运行。manager会重新创建一个worker进程。此选项用来防止worker进程内存溢出。    ]);/** 监听连接进入事件* @param fd 客户端的唯一标识* @param from_id 相当线程标识*/$serv-&gt;on(&#39;Connect&#39;, function ($serv, $fd,$from_id) {      echo &quot;Client: 用户唯一标识：{$fd}-线程唯一标识：{$from_id}Connect.\n&quot;;});/** 监听数据接收事件* @param fd 客户端唯一标识* @param from_id 相当线程标识× @param data 接受到的数据*/$serv-&gt;on(&#39;Receive&#39;, function ($serv, $fd, $from_id, $data) {    $serv-&gt;send($fd, &quot;Server: 用户唯一标识：{$fd}-线程唯一标识：{$from_id}&quot;.&#39;返回的数据&#39;.$data);});//监听连接关闭事件$serv-&gt;on(&#39;Close&#39;, function ($serv, $fd) {    echo &quot;Client: Close.\n&quot;;});//启动服务器$serv-&gt;start(); </code></pre><p>首先到此我们就已经创建了一个简单的 TCP 服务器端，并且做到了一个事件的监听与处理，此时我们就可以用 telnet 连接 TCP 服务器。</p><h4 id="telnet-连接-TCP-服务器"><a href="#telnet-连接-TCP-服务器" class="headerlink" title="telnet 连接 TCP 服务器"></a>telnet 连接 TCP 服务器</h4><pre><code>telnet 127.0.0.1 9500</code></pre><blockquote><p>进入 telnet 之后 ctrl+] 之后 quit 可以退出连接客户端</p></blockquote><p><img src="https://i.loli.net/2019/09/30/gLP32SjvcFGEWB7.png" alt></p><h4 id="简单了解-Server-函数"><a href="#简单了解-Server-函数" class="headerlink" title="简单了解 Server 函数"></a>简单了解 Server 函数</h4><p>在这个简单的 TCP 服务器端连接当中我们用到了 四个函数：construct、set、on、send、start</p><ul><li>construct：创建一个「异步」对象。<ul><li>简单来看，必备的二个参数：string $host , int $port 分别为监听的 ip 与端口号。</li><li><a href="https://wiki.swoole.com/wiki/page/14.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>set：设置运行时服务器的各项参数，且注意 set 必须在 start 之前调用。<ul><li>可以不用设置，但建议添加参数</li><li><a href="https://wiki.swoole.com/wiki/page/13.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>on：做了一个事件的监听。<ul><li>参数1：为回调名称，大小写不敏感，注意名称不能加 on</li><li>参数2：PHP 的回调函数 他里面一般三个参数：Server 对象，客户端唯一标识，线程唯一标识</li><li><a href="https://wiki.swoole.com/wiki/page/142.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>send：向客户端发送数据<ul><li>参数1：客户端唯一标识</li><li>参数2：发送的数据，<code>TCP</code>协议最大不得超过<code>2M</code>但是可以修改<a href="https://wiki.swoole.com/wiki/page/p-buffer_output_size.html" target="_blank" rel="noopener">buffer_output_size</a> 改变允许发送的最大包长度</li><li><a href="https://wiki.swoole.com/wiki/page/p-server/send.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>start：启动服务器，并且监听 TCP/UDP 端口。<ul><li>没有参数</li><li><a href="https://wiki.swoole.com/wiki/page/19.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li></ul><h3 id="创建同步-TCP-客户端"><a href="#创建同步-TCP-客户端" class="headerlink" title="创建同步 TCP 客户端"></a>创建同步 TCP 客户端</h3><pre><code>&lt;?php// 创建 clinet 对象$client = new swoole_client(SWOOLE_SOCK_TCP);// 连接 serverif(!$client-&gt;connect(&#39;192.168.0.111&#39;,9500)) {   die(&#39;无法连接到服务器端&#39;);}// cli 输入提示fwrite(STDOUT,&#39;请输入发送的消息&#39;);// cli 输入数据获取$msg =fgets(STDIN);// 发送数据给 server 成功返回 true 失败返回 falseif(!$client-&gt;send($msg)){    die(&#39;发送数据失败&#39;);}   // 接收 server 返回的数据if(!$data = $client-&gt;recv()){    die(&#39;接受数据失败&#39;);}echo $data;// 关闭链接$client-&gt;close();</code></pre><p><img src="https://i.loli.net/2019/09/30/VYDUWbug8S3L7Qj.png" alt></p><h4 id="简单了解-Clinet-函数"><a href="#简单了解-Clinet-函数" class="headerlink" title="简单了解 Clinet 函数"></a>简单了解 Clinet 函数</h4><p>在这个简单的 TCP 服务器端连接当中我们用到了 四个函数：construct、connect、send、recv、close</p><ul><li>construct：创建 clinet 对象<ul><li>参数1：socket 的类型，如 TCP/UDP 使用 Swoole 常量定义</li><li><a href="https://wiki.swoole.com/wiki/page/29.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>connect：连接服务器端<ul><li>参数1：服务器地址</li><li>参数2：服务器端口号</li><li><a href="https://wiki.swoole.com/wiki/page/30.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>send：发送数据到服务器<ul><li>参数1：发送的数据，string 类型 成功返回长度失败返回 false</li><li><a href="https://wiki.swoole.com/wiki/page/31.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>recv：接收服务器端数据<ul><li><a href="https://wiki.swoole.com/wiki/page/32.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li><li>close：关闭连接<ul><li><a href="https://wiki.swoole.com/wiki/page/p-client/close.html" target="_blank" rel="noopener">具体官方文档</a></li></ul></li></ul><h3 id="创建-HTTP-服务器"><a href="#创建-HTTP-服务器" class="headerlink" title="创建 HTTP 服务器"></a>创建 HTTP 服务器</h3><pre><code>&lt;?php$http = new Swoole\Http\Server(&#39;0.0.0.0&#39;,9500);# 绑定事件$http-&gt;on(&#39;request&#39;,function($request,$response){        $response-&gt;header(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;);        $response-&gt;end(&quot;&lt;h1&gt;你好世界&lt;/h1&gt;&quot;);});# 开启服务$http-&gt;start();</code></pre><p><img src="https://i.loli.net/2019/10/08/EWktuiJSlhqDUV7.png" alt></p><blockquote><p>Http\Server 是继承与 Server 其使用基本一样，但是有些地方也有不同，在官方文档里面需要注意的地方也详细的说明了。</p><p>Swoole 虽然可以创建 Http 服务，性能也非常强大，但是对于 Http 支持的并不完整，还不能完全取代传统的 Web 服务器软件。Swoole 的强大之处只在于处理 PHP 逻辑的能力上，所以最好的选择还是结合 Nginx。</p></blockquote><blockquote><p>学习当中。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> swoole </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swoole </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-JWT</title>
      <link href="/2019/09/18/Laravel%E4%B9%8BJWT/"/>
      <url>/2019/09/18/Laravel%E4%B9%8BJWT/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p><a href="https://jwt.io/" target="_blank" rel="noopener">JWT</a> 是 JSON Web Token 的缩写，是一个非常轻巧的规范，这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。</p></blockquote><p>JWT 由头部（header）、载荷（payload）与签名（signature）组成，一个 JWT 类似下面这样：</p><pre class="line-numbers language-‘"><code class="language-‘">{    "typ":"JWT",    "alg":"HS256"}{    "iss":"http://larabbs.test",签发人    "iat":1515733500,签发时间    "exp":1515737100,过期时间    "nbf":1515733500,生效时间，在此之前是无效的    "jti":"c3U4VevxG2ZA1qhT",编号    "sub":1,主题    "prv":"23bd5c8949f600adb39e701c400872db7a5976f7"}signature<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>头部申明了加密算法；</li><li>载荷中有两个比较重要的数据，<code>exp</code> 是过期时间，<code>sub</code> 是 JWT 的主体，<strong>这里就是用户的 id</strong>；</li><li>最后的 signature 是由服务器进行的签名，保证了 token 不被篡改。</li></ul><p>用户 id，过期时间等数据都保存在 Token 中了，所以并不需要将 Token 保存在服务器中，客户端请求的时候在 Header 中携带 Token，服务器获取 Token 后，进行 <code>base64_decode</code> 即可获取数据进行校验，由于已经有了签名，所以不用担心数据被篡改。</p><p><strong>加密 Token 解密</strong></p><p><img src="https://i.loli.net/2019/11/17/jXCUve2W8xqMGpO.png" alt></p><blockquote><p>JWT 最后是通过 Base64 编码的，也就是说，它可以被翻译回原来的样子来的。所以不要在 JWT 中存放一些敏感信息。</p></blockquote><h3 id="安装-jwt-auth"><a href="#安装-jwt-auth" class="headerlink" title="安装 jwt-auth"></a>安装 jwt-auth</h3><pre><code>$ composer require tymon/jwt-auth</code></pre><p>安装完成后，我们需要设置一下 JWT 的 secret，这个 secret 很重要，用于最后的签名，更换这个 secret 会导致之前生成的所有 token 无效。</p><pre><code>$ php artisan jwt:secret</code></pre><p>可以看到在 .env 文件中，增加了一行 <code>JWT_SECRET</code>。</p><p><strong>Laravel 5.5 版本以上不需要在添加服务提供者。</strong></p><h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><pre><code>php artisan vendor:publish --provider=&quot;Tymon\JWTAuth\Providers\LaravelServiceProvider&quot;</code></pre><p>您现在应该有一个<code>config/jwt.php</code>文件，允许您配置此程序包的基础知识。</p><p>修改 <code>config/auth.php</code>，将 <code>api guard</code> 的 <code>driver</code> 改为 <code>jwt</code>。</p><p><em>config/auth.php</em></p><pre><code>&#39;guards&#39; =&gt; [    &#39;web&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;session&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],    &#39;api&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;jwt&#39;,        &#39;provider&#39; =&gt; &#39;users&#39;,    ],],# 注意一下模型的服务提供者，默认使用的 app\user &#39;providers&#39; =&gt; [    &#39;users&#39; =&gt; [        &#39;driver&#39; =&gt; &#39;eloquent&#39;,        &#39;model&#39; =&gt; App\Http\Model\User::class,    ],</code></pre><p>如果使用了 Dingo API 修改 <code>config/api.php</code>，auth 中增加 JWT 相关的配置</p><p><em>config/api.php</em></p><pre><code>&#39;auth&#39; =&gt; [    &#39;jwt&#39; =&gt; &#39;Dingo\Api\Auth\Provider\JWT&#39;,],</code></pre><p>user 模型需要继承 <code>Tymon\JWTAuth\Contracts\JWTSubject</code> 接口，并实现接口的两个方法 getJWTIdentifier () 和 getJWTCustomClaims ()。</p><p><em>app\Models\User.php</em></p><pre><code>&lt;?phpnamespace App\Models;use Tymon\JWTAuth\Contracts\JWTSubject;use Illuminate\Notifications\Notifiable;use Illuminate\Foundation\Auth\User as Authenticatable;class User extends Authenticatable implements JWTSubject{    use Notifiable;    public function getJWTIdentifier()    {        return $this-&gt;getKey();    }    public function getJWTCustomClaims()    {        return [];    }}</code></pre><p>getJWTIdentifier 返回了 User 的 id，getJWTCustomClaims 是我们需要额外再 JWT 载荷中增加的自定义内容，这里返回空数组。</p><p><code>jwt-auth</code> 有两个重要的参数，可以在 <code>config/jwt.php</code> 中进行设置</p><ul><li>JWT_TTL 生成的 token 在多少分钟后过期，默认 60 分钟</li><li>JWT_REFRESH_TTL 生成的 token，在多少分钟内，可以刷新获取一个新 token，默认 20160 分钟，14 天。</li></ul><p>这里需要理解一下 JWT 的过期和刷新机制，过期很好理解，超过了这个时间，token 就无效了。刷新时间一般比过期时间长，只要在这个刷新时间内，即使 token 过期了， 依然可以换取一个新的 token，以达到应用长期可用，不需要重新登录的目的。</p><h3 id="助手函数"><a href="#助手函数" class="headerlink" title="助手函数"></a>助手函数</h3><pre><code>// 尝试通过某些凭据对用户进行身份验证$token = auth()-&gt;attempt($request);// 获取当前经过身份验证的用户。$result = auth()-&gt;user();// 注销用户-这将使当前令牌无效并取消验证用户的身份auth()-&gt;logout(); Token 可以继续使用直到 exp 过期auth()-&gt;logout(true);  马上把当前的 Token 永久性的加入黑名单// 刷新令牌，这会使当前令牌无效auth()-&gt;resfresh();auth()-&gt;resfresh(true,true); 将 true 作为第一个参数传递，以强制将令牌永久性列入黑名单。第二个参数将重置新令牌的声明// 使令牌无效（将其添加到黑名单）auth()-&gt;invalidate();auth()-&gt;invalidate(true); 马上把当前的 Token 永久性的加入黑名单// 判断当前用户是否登录auth()-&gt;check();</code></pre><h3 id="多用户验证"><a href="#多用户验证" class="headerlink" title="多用户验证"></a>多用户验证</h3><p>1、创建 Admin 模型，其他操作与 User 一致</p><pre><code>php artisan make:model Admin</code></pre><p>2、修改<code>config\auth.php</code>配置</p><pre><code> &#39;guards&#39; =&gt; [        &#39;admin&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;jwt&#39;,            &#39;provider&#39; =&gt; &#39;admins&#39;,        ],        &#39;api&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;jwt&#39;,            &#39;provider&#39; =&gt; &#39;users&#39;,            &#39;hash&#39; =&gt; false,        ],    ], &#39;providers&#39; =&gt; [        &#39;users&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; App\Http\Model\User::class,        ],        &#39;admins&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;eloquent&#39;,            &#39;model&#39; =&gt; App\Http\Model\Admin::class,        ],    ],    </code></pre><blockquote><p>JWT 超级详细的讲解博文：<a href="https://learnku.com/articles/10885/full-use-of-jwt#d08bfb" target="_blank" rel="noopener">https://learnku.com/articles/10885/full-use-of-jwt#d08bfb</a></p><p>JWT 官方使用手册：<a href="https://jwt-auth.readthedocs.io/en/develop/" target="_blank" rel="noopener">https://jwt-auth.readthedocs.io/en/develop/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP之单元测试</title>
      <link href="/2019/09/16/PHP%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2019/09/16/PHP%E4%B9%8B%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>长听言软件开发工程当中〔单元测试〕属于必不可缺少的一个环节，但是工作以来重来没有做过〔单元测试〕。感觉这方面知识很欠缺，所以准备好好学习这个〔单元测试〕。在我们 PHP 当中使用 PHPunit 来做〔单元测试〕。那么为什么需要学习〔单元测试〕呢？<strong>只要你想到输入一些东西到 print 语句或调试表达式中，就用测试代替它。</strong> –Martin Fowler</p><p>总之一句话，使用 <code>phpunit</code> 进行自动测试，会使你的代码更健壮，减少后期维护的成本，也是一种比较标准的规范，现如今流行的 PHP 框架都带了单元测试，如 Laraval,Symfony,Yii2 等，单元测试已经成了标配。</p><p>另外，单元测试用例是通过命令操控测试脚本的，而不是通过浏览器访问URL的。</p><blockquote><p>学习当中。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP入门到精通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-自定义异常响应</title>
      <link href="/2019/09/11/Laravel%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%93%8D%E5%BA%94/"/>
      <url>/2019/09/11/Laravel%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Laravel 中所有异常都是由 <code>App\Exceptions\Handler</code> 类处理。打开此类文件，你可以发现 <code>render</code> 方法，<code>render</code> 方法负责将异常转换为 HTTP 响应。默认情况下，异常将传递给为你生成响应。注意如果使用了 Dingo API 来处理请求，异常就不再经过 <code>Exceptions/Handler</code> 了，而是走 <a href="https://learnku.com/docs/dingo-api/2.0.0/Errors-And-Error-Responses/1447" target="_blank" rel="noopener">Dingo</a> 自己写的异常处理。</p><p><strong>什么是异常</strong></p><blockquote><p>异常是运行中超出了你程序预期的一个东西。</p></blockquote><p>异常就是一个意外，影响了你的程序正常运行。但是如果你用好异常，会让你的程序便于解耦，结构更加清晰明了。</p><p>最开始接触异常的是在学习 PHP 时，到后来进入第一家公司工作时我总是在 Servers 层当写中很多对于一些程序控制的 return 。那时的我是第一次正式的写项目，开始的时候我的前任也没有说我，等写玩一个模块后对我说其实这些完全可以交给一个异常去处理这样做的好处在于 Servers 里的代码能更加结构化，增加可读性，还能方便统一维护错误输出。</p><h3 id="自定义异常处理"><a href="#自定义异常处理" class="headerlink" title="自定义异常处理"></a>自定义异常处理</h3><pre><code>&lt;?phpnamespace App\Exceptions;use Exception;use Throwable;class ApiException extends Exception{    public function __construct(string $message = &quot;&quot;, int $code = 0, Throwable $previous = null)    {        parent::__construct($message, $code, $previous);    }    public function report()    {        # 这里自定义发生异常发生时要额外做的事情    }    public function render()    {        # 可以 HTTP 的响应 也可以渲染一个网页, 也可以重定向一个页面        return response([&#39;status&#39; =&gt; $this-&gt;code, &#39;message&#39; =&gt; $this-&gt;message], $this-&gt;code);    }}</code></pre><p>之后我们可以就可以捕获异常</p><pre><code>try{}catch (){}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-自定义异常响应 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP函数记录</title>
      <link href="/2019/09/10/PHP%E6%AF%8F%E6%97%A5%E4%B8%80%E5%87%BD%E6%95%B0/"/>
      <url>/2019/09/10/PHP%E6%AF%8F%E6%97%A5%E4%B8%80%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="str-pad"><a href="#str-pad" class="headerlink" title="str_pad"></a>str_pad</h3><p>使用另一个字符串将字符串填充到某个长度</p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">str_pad</span><span class="token punctuation">(</span><span class="token function">random_int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">STR_PAD_LEFT</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="random-int"><a href="#random-int" class="headerlink" title="random_int"></a>random_int</h3><p>生成加密安全的伪随机整数</p><pre class="line-numbers language-php"><code class="language-php"><span class="token function">random_int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="hash-equals"><a href="#hash-equals" class="headerlink" title="hash_equals"></a>hash_equals</h3><p>定时攻击安全字符串比较</p><pre class="line-numbers language-php"><code class="language-php">hash_equals （ string <span class="token variable">$known_string</span> ， string <span class="token variable">$user_string</span> ）： bool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>无论它们是否相等，都使用相同的时间比较两个字符串。</p><p>该功能应用于减轻定时攻击; 例如，在测试<a href="function.crypt.html">crypt（）</a>密码哈希时。</p><h3 id="array-flip"><a href="#array-flip" class="headerlink" title="array_flip"></a>array_flip</h3><p>删除重复数组元素</p><h3 id="array-merge"><a href="#array-merge" class="headerlink" title="array_merge"></a>array_merge</h3><p>删除数组下标</p><h3 id="strip-tags"><a href="#strip-tags" class="headerlink" title="strip_tags"></a>strip_tags</h3><p>从字符串中去除 HTML 和 PHP 标记</p><h3 id="array-walk-recursive"><a href="#array-walk-recursive" class="headerlink" title="array_walk_recursive"></a>array_walk_recursive</h3><p>对数组中的每个成员递归地应用用户函数</p><blockquote><p>整理当中。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-第三方登录</title>
      <link href="/2019/09/09/Laravel%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
      <url>/2019/09/09/Laravel%E4%B9%8B%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>所谓的第三方登录，就是利用用户在第三方平台上已有的账号来快速完成自己应用的登录或者注册的功能，常用的协议为 OAuth 2.0，基本上每个 APP，都会集成微信，微博等第三方登录，方便用户快速的登录并开始使用。当然需要看一下 <a href>Socialite 社会化登录</a>能更好的使用第三方包。</p><h3 id="微信登录"><a href="#微信登录" class="headerlink" title="微信登录"></a>微信登录</h3><p>登录登录的流程图：</p><p><img src="https://i.loli.net/2019/09/12/DkGyJ3gdxB8r7vC.png" alt></p><h4 id="1、获取临时票据-CODE"><a href="#1、获取临时票据-CODE" class="headerlink" title="1、获取临时票据 CODE"></a>1、获取临时票据 CODE</h4><pre><code>https://open.weixin.qq.com/connect/oauth2/authorize?appid=自己的APPID&amp;redirect_uri=自己的网址&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect</code></pre><p><img src="https://i.loli.net/2019/09/12/coS8U54QW6FBkn7.png" alt></p><h4 id="2、获取-access-token-与-open-id"><a href="#2、获取-access-token-与-open-id" class="headerlink" title="2、获取 access_token 与 open_id"></a>2、获取 access_token 与 open_id</h4><pre><code>https://api.weixin.qq.com/sns/oauth2/access_token?appid=自己的APPID&amp;secret=自己的AppSecret&amp;code=获取的CODE&amp;grant_type=authorization_code</code></pre><p><img src="https://i.loli.net/2019/09/12/vMzCp2Nq5BDiX6k.png" alt></p><h4 id="3、获取个人信息"><a href="#3、获取个人信息" class="headerlink" title="3、获取个人信息"></a>3、获取个人信息</h4><pre><code>https://api.weixin.qq.com/sns/userinfo?access_token=自己的access_token&amp;openid=OPENID&amp;lang=zh_CN</code></pre><pre><code>{    &quot;openid&quot;: &quot;xxxxxxxxxxx&quot;,    &quot;nickname&quot;: &quot;哪吒大战假老练&quot;,    &quot;sex&quot;: 1,    &quot;language&quot;: &quot;zh_CN&quot;,    &quot;city&quot;: &quot;资阳&quot;,    &quot;province&quot;: &quot;四川&quot;,    &quot;country&quot;: &quot;中国&quot;,    &quot;headimgurl&quot;: &quot;&quot;,    &quot;privilege&quot;: []}</code></pre><h3 id="扩展包"><a href="#扩展包" class="headerlink" title="扩展包"></a>扩展包</h3><p><a href="https://socialiteproviders.netlify.com/" target="_blank" rel="noopener">Socialite Providers</a> 超级多的第三方开箱就用包。只要使用的 OAuth 2.0 协议的第三方登录，都可以用同样的方法去实现登录。</p><h4 id="1、install"><a href="#1、install" class="headerlink" title="1、install"></a>1、install</h4><pre><code>$ composer require socialiteproviders/weixin</code></pre><p>Laravel 5.5 版本以上不需要在<code>confi/app.php</code>添加服务提供者，Laravel 会自动发现包</p><h4 id="2、事件监听器"><a href="#2、事件监听器" class="headerlink" title="2、事件监听器"></a>2、事件监听器</h4><p>在<code>app/Providers/EventServiceProvider</code>当中的 <code>listen[]</code>添加</p><pre><code>/** * The event handler mappings for the application. * * @var array */protected $listen = [    \SocialiteProviders\Manager\SocialiteWasCalled::class =&gt; [        // add your listeners (aka providers) here        &#39;SocialiteProviders\\Weixin\\WeixinExtendSocialite@handle&#39;,    ],];</code></pre><h4 id="3、配置设置"><a href="#3、配置设置" class="headerlink" title="3、配置设置"></a>3、配置设置</h4><p>添加到<code>config/services.php</code></p><pre><code>&#39;weixin&#39; =&gt; [    &#39;client_id&#39; =&gt; env(&#39;WEIXIN_KEY&#39;),    &#39;client_secret&#39; =&gt; env(&#39;WEIXIN_SECRET&#39;),    &#39;redirect&#39; =&gt; env(&#39;WEIXIN_REDIRECT_URI&#39;)],</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>$user = Socialite::driver(&#39;Weixin&#39;)-&gt;user();$accessTokenResponseBody = $user-&gt;accessTokenResponseBody;</code></pre><p>简单的使用</p><pre><code>        # 加载驱动        $driver = Socialite::driver($type);        if ($request-&gt;code)        {            # 获得 access_token 和 open_id            $token = $driver-&gt;getAccessTokenResponse($request-&gt;code)[&#39;access_token&#39;];        }else{            $token = $request-&gt;access_token;            # 设置 open_id            $driver-&gt;setOpenId($request-&gt;open_id);        }        # 获取用户信息        $result = $driver-&gt;userFromToken($token);        # 获取 unionid 只有在用户将公众号绑定到微信开放平台帐号后，才会出现 unionid 字段        $unionid = $result-&gt;offsetExists(&#39;unionid&#39;) ? $result-&gt;offsetGet(&#39;unionid&#39;) : null;</code></pre><p>核心源码在于<code>vendor/socialiteproviders/weixin/Provider.php</code></p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker遇到的一些问题</title>
      <link href="/2019/09/09/Docker%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/09/Docker%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h3><p>在之前也一直没有去执行过 Laravel 的 migrate 命令。今天在想要写一个朋友给的项目的时候，需要创建表，夸夸一顿操作。结果就是：</p><pre><code>could not find driver</code></pre><p>找不到驱动，下意识的就去看 <code>config/database.php</code>配置文件去了，认真的检查了一遍没有问题啊！然后又去<code>.env</code>看连接的信息是否哪里有问题，没问题啊！！！心里又在想是不是扩展没打开，马上 exec 到 Dokcer 的容器当中 PHP -m 查看 PDO 相关的扩展是不是没有。（其实问题已经出现了）</p><p>检查了一遍 Dokcer 容器里面的扩展发现还是没有问题，回过头来又去执行 migrate 还是不行。谷歌、百度了很久也没有找到解决的办法。实在没有办法了，就去救助我一个大哥了，搞了一些东西问题也没有解决。</p><p>’你去 Docker 里面运行一下  php artisan migrate ‘，恍然大悟！！！赶快 exec 到容器当中，执行了一下命令。。。成功了我靠搞半天原来是这样！！！因为宿主机没有这个环境，使用的都是 Docker 里面的环境，还在搞半天搞出一朵花来也运行不了！当然你要是同步 Docker 的环境就完全没有问题了。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><pre><code>＃　我是在一个接口里面写了一个　终端命令，最好还是同步下 PHP 的环境到本机下面exec(&#39;cd ../;php artisan migrate&#39;)；</code></pre><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><p>今天又跳坑里面了，自己想答一个 MySQL 的读写分离，创建了一个容器，绑定了端口 3307 结果第三方软件一直连接不上。</p><p>宿主机绑定了 3307 端口，但是 MySQL 忘记修改端口了，MySQL 默认使用的 3306。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-DingoApi</title>
      <link href="/2019/09/08/Laravel%E4%B9%8BDingoApi/"/>
      <url>/2019/09/08/Laravel%E4%B9%8BDingoApi/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p><a href="https://github.com/dingo/api/" target="_blank" rel="noopener">dingo/api</a> 是一个 Lumen 和 Laravel 都可用的 RestFul 工具包，帮助我们快速的开始构建 RestFul Api。我们的目的是教会大家如何快速的搭建并使用这个包，更多的功能，还需要你仔细阅读 DingoApi 的 <a href="https://github.com/dingo/api/wiki" target="_blank" rel="noopener">文档</a> 来深入的学习和理解，<a href="https://github.com/liyu001989/dingo-api-wiki-zh" target="_blank" rel="noopener">这里</a>有一份中英对照的翻译，或许能帮到你。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>$ composer require dingo/api</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>先将 dingo 的配置文件发布出来</p><pre><code>$ php artisan vendor:publish --provider=&quot;Dingo\Api\Provider\LaravelServiceProvider&quot;</code></pre><p>执行成功后，我们会在 <code>config</code> 目录先看到 <code>api.php</code> 文件，打开文件我们可以看到所有的配置都是可以在 <code>.env</code> 中修改，下面我们主要讲解一下我们需要用到的配置。</p><p>1、API_STANDARDS_TREE 有是三个值可选</p><ul><li><code>x</code> 本地开发的或私有环境的</li><li><code>prs</code> 未对外发布的，提供给公司 app，单页应用，桌面应用等</li><li><code>vnd</code> 对外发布的，开放给所有用户</li></ul><pre><code>API_STANDARDS_TREE=prs</code></pre><p>2、API_SUBTYPE 一般情况下是我们项目的简称</p><pre><code>API_SUBTYPE=make</code></pre><p>3、API_PREFIX 和 API_DOMAIN<br>对于一个项目，通过前缀或者子域名的方式来区分开 API 与 Web 等页面访问地址是十分有必要的。假如正式上线的项目地址为 <code>www.make.com</code>，我们可以为 API 添加一个前缀</p><pre><code>API_PREFIX=api</code></pre><p>通过 <code>www.make.com/api</code> 来访问 API。<br>或者有可能单独配置一个子域名 <code>api.make.com</code></p><pre><code>API_DOMAIN=api.make.com</code></pre><p>通过 api.make.com 来访问 API。</p><p>特别要注意的是：<strong>前缀和子域名，两者有且只有一个</strong></p><p>4、API_VERSION<br>默认的 API 版本，当我们没有传 <code>Accept</code> 头的时候，默认访问该版本的 API。一般情况下配置 v1 即可。</p><pre><code>API_VERSION=v1# 请求头当中添加，选择版本Accept Accept: application/prs.make.v1+jsonAccept Accept: application/prs.make.v2+json</code></pre><p>5、API_STRICT<br>是否开启严格模式，如果开启，则必须使用 <code>Accept</code> 头才可以访问 API，也就是说直接通过浏览器，访问某个 GET 调用的接口，如 <code>https://api.larabbs.com/users</code>，将会报错。必须使用 Postman 之类的调试工具，设置 <code>Accept</code> 后才可访问。可以根据需求开启，默认情况下为 false。</p><p>6、API_DEBUG<br>测试环境，打开 debug，方便我们看到错误信息，定位错误。<br>最后我们的配置如下</p><pre><code>API_DEBUG=true</code></pre><p>7、配置 <code>.env</code></p><pre><code>API_STANDARDS_TREE=prsAPI_SUBTYPE=makeAPI_DOMAIN=api.make.comAPI_VERSION=v1API_DEBUG=true</code></pre><p>8、使用 dingo</p><pre><code># 依然是在 route/api.php 当中使用$api = app(&#39;Dingo\Api\Routing\Router&#39;);$api-&gt;version(&#39;v1&#39;, function($api) {    $api-&gt;get(&#39;version&#39;, function() {        return view(&#39;welcome&#39;);    });});$api-&gt;version(&#39;v2&#39;, function($api) {    $api-&gt;get(&#39;version&#39;, function() {        return response(&#39;this is version v2&#39;);    });});# 创建一个 Controller 类&lt;?phpnamespace App\Http\Controllers\v1;use Illuminate\Http\Request;use App\Http\Controllers\Controller as BaseController;use Dingo\Api\Routing\Helpers;class Controller extends BaseController{    use Helpers;}</code></pre><blockquote><p>注意如果是有 laravel-debugbar 那么就需要在 config/debugbar.php 把配置修改以下</p></blockquote><pre><code>&#39;enabled&#39; =&gt; env(&#39;APP_DEBUG&#39;, false)# 修改为&#39;enabled&#39; =&gt; env(&#39;DEBUGBAR_ENABLE&#39;, false)# 如果需要就在 .env 当中开启DEBUGBAR_ENABLE=true</code></pre><blockquote><p>提示：由于路由被 DingoApi 接管了，如果将来部署上线后你需要缓存路由，可以使用 <code>php artisan api:cache</code> 代替 <code>php artisan route:cache</code> ，本地测试请<strong>不要执行这个命令</strong>。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-日志操作</title>
      <link href="/2019/09/07/Laravel%E4%B9%8B%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/"/>
      <url>/2019/09/07/Laravel%E4%B9%8B%E6%97%A5%E5%BF%97%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>为了帮助你更多的了解应用程序中到底发生了什么，Laravel 提供了强大的日志服务，允许你将日志消息、系统错误日志记录到文件，甚至使用 Slack 通知到你的整个团队。</p><p>在 Laravel 框架中，Laravel 使用 <a href="https://github.com/Seldaek/monolog" target="_blank" rel="noopener">Monolog</a> 库，它为各种强大的日志处理提供支持。Laravel 使配置这些处理程序变得简单，允许你混合并匹配它们自定义的应用程序日志处理。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>所有的应用程序日志系统配置都位于 <code>config/logging.php</code> 配置文件中。默认使用大概配置如下：</p><pre><code># 默认使用的 stack 通道&#39;default&#39; =&gt; env(&#39;LOG_CHANNEL&#39;, &#39;stack&#39;),# 注意真正在使用的是 .env 文件当中的 LOG_CHANNEL=stack，修改这里即可修改默认通道&#39;channels&#39; =&gt; [         # 默认使用的通道        &#39;stack&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;stack&#39;,# 驱动            &#39;channels&#39; =&gt; [&#39;daily&#39;], # 聚合，支持多通道            &#39;ignore_exceptions&#39; =&gt; false, # 默认忽略异常        ],         # stack 又聚合了 daily 通道，它每天的日志信息都会输出到 storage/log 文件下        &#39;daily&#39; =&gt; [            &#39;driver&#39; =&gt; &#39;daily&#39;, # 驱动            &#39;path&#39; =&gt; storage_path(&#39;logs/laravel.log&#39;),# 日志文件存储路径            &#39;level&#39; =&gt; &#39;debug&#39;, # 八大错误级别            &#39;days&#39; =&gt; 14, # 日志分片周期，多少天一个文件        ],    ]</code></pre><h3 id="配置-Single-和-Daily-通道"><a href="#配置-Single-和-Daily-通道" class="headerlink" title="配置 Single 和 Daily 通道"></a>配置 Single 和 Daily 通道</h3><p><code>single</code> 和 <code>daily</code> 通道包含三个可选配置项：<code>bubble</code> 、<code>permission</code> 和 <code>locking</code></p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>名称</td><td>描述</td><td>默认值</td></tr><tr><td><code>bubble</code></td><td>消息处理后，指示消息是否推送到其他通道</td><td><code>true</code></td></tr><tr><td><code>permission</code></td><td>日志文件权限</td><td><code>0644</code></td></tr><tr><td><code>locking</code></td><td>写入之前尝试锁定日志文件</td><td></td></tr></tbody></table><h3 id="日志写入的八大级别"><a href="#日志写入的八大级别" class="headerlink" title="日志写入的八大级别"></a>日志写入的八大级别</h3><table><thead><tr><th align="left">错误等级</th><th align="left">描述</th><th align="left">整型值</th><th align="left">应用场景</th></tr></thead><tbody><tr><td align="left">debug</td><td align="left">代码引用为 “MonologLogger::DEBUG”</td><td align="left">100</td><td align="left">紧急，如系统挂掉</td></tr><tr><td align="left">info</td><td align="left">代码引用为 “MonologLogger::INFO”</td><td align="left">200</td><td align="left">需要立即采取行动，如数据库异常等</td></tr><tr><td align="left">notice</td><td align="left">代码引用为 “MonologLogger::NOTICE”</td><td align="left">250</td><td align="left">严重问题，如异常</td></tr><tr><td align="left">warning</td><td align="left">代码引用为 “MonologLogger::WARNING”</td><td align="left">300</td><td align="left">运行时错误，不需要立即处理但需要被记录和监控</td></tr><tr><td align="left">error</td><td align="left">代码引用为 “MonologLogger::ERROR”</td><td align="left">400</td><td align="left">警告但不是错误，比如使用了被废弃的API</td></tr><tr><td align="left">critical</td><td align="left">代码引用为 “MonologLogger::CRITICAL”</td><td align="left">500</td><td align="left">普通但值得注意的事件</td></tr><tr><td align="left">alert</td><td align="left">代码引用为 “MonologLogger::ALERT”</td><td align="left">550</td><td align="left">感兴趣的事件，比如登录、退出</td></tr><tr><td align="left">emergency</td><td align="left">代码引用为 “MonologLogger::EMERGENCY”</td><td align="left">600</td><td align="left">详细的调试信息</td></tr></tbody></table><h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><pre><code>&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;# 引入 Loguse Illuminate\Support\Facades\Log;class UsersController extends Controller{    public function get()    {        # 写入日志，第二次参数为数组在日志文件当中转换为 JSON 默认使用配置文件中默认的通道        Log::info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; \request()-&gt;ip()]);        # 以上是写入默认配置文件当中的通道，除此之外还可以指定写入的通道        Log::channel(&#39;single&#39;)-&gt;info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; \request()-&gt;ip()]);        # 如果想要创建一个由多通道构成的按需记录的堆栈，可以使用 stack 方法：        Log::stack([&#39;single&#39;, &#39;slack&#39;])-&gt;info(&#39;Something happened!&#39;);    }}</code></pre><p>日志文件的结果：</p><pre><code># 注意虽然他们在日志文件里面的结果都是一样，但是他们存储的日志文件是不一样的一个单一、一个日常[2019-09-07 13:58:05] local.INFO: 记录的日志 {&quot;ip&quot;:&quot;xxxxxxxxxxx&quot;} </code></pre><h3 id="自定义-Monolog-通道"><a href="#自定义-Monolog-通道" class="headerlink" title="自定义 Monolog 通道"></a>自定义 Monolog 通道</h3><p>首先我们需要在<code>config/logging.php</code>中添加一个 tap 数组。</p><pre><code># 自定义 monolog 通道&#39;monolog&#39; =&gt; [    &#39;driver&#39; =&gt; &#39;daily&#39;, # 使用的 daily 每日记录    &#39;tap&#39; =&gt; [App\Logging\CustomizeFormatter::class],# 接口    &#39;permission&#39;=&gt; 0777, # 权限    &#39;path&#39; =&gt; storage_path(&#39;logs/laravel.log&#39;), # 存储的路径    &#39;level&#39; =&gt; &#39;debug&#39;, # 八大错误级别    &#39;days&#39; =&gt; 1, # 日志分片],</code></pre><p>创建 CustomizeFormatter.php</p><pre><code>&lt;?phpnamespace App\Logging;# 引入自定义的 Formatteruse App\Logging\JsonFormatter;class CustomizeFormatter{    /**     * 自定义给定的日志实例。     *     * @param  \Illuminate\Log\Logger  $logger     * @return void     */    public function __invoke($logger)    {        foreach ($logger-&gt;getHandlers() as $handler) {            $handler-&gt;setFormatter(new JsonFormatter());        }    }}</code></pre><p>创建 JsonFormatter.php</p><pre><code>&lt;?phpnamespace App\Logging;use Monolog\Formatter\JsonFormatter as BaseJsonFormatter;class JsonFormatter extends BaseJsonFormatter{    public function format(array $record) ：string　    {        // 这个就是最终要记录的数组，最后转成Json并记录进日志        $newRecord = [            &#39;time&#39; =&gt; $record[&#39;datetime&#39;]-&gt;format(&#39;Y-m-d H:i:s&#39;),            &#39;message&#39; =&gt; $record[&#39;message&#39;],        ];        if (!empty($record[&#39;context&#39;])) {            $newRecord = array_merge($newRecord, $record[&#39;context&#39;]);        }        //$json = &#39;aaa,bbb,ccc&#39;;  // 这是最终返回的记录串，可以按自己的需求改        $json = $this-&gt;toJson($this-&gt;normalize($newRecord), true) . ($this-&gt;appendNewline ? &quot;\n&quot; : &#39;&#39;);        return $json;    }}</code></pre><p>使用自定义的通道</p><pre><code>Log::channel(&#39;monolog&#39;)-&gt;info(&#39;记录的日志&#39;,[&#39;ip&#39; =&gt; \request()-&gt;ip()]);# 结果{&quot;time&quot;:&quot;2019-09-07 16:37:52&quot;,&quot;message&quot;:&quot;记录的日志&quot;,&quot;ip&quot;:&quot;xxxxxx&quot;}</code></pre><blockquote><p>重写父类的时候，一定要注意，如果父类有返回值限制的话，那么也必须跟父类一个类型不然就会报错。这的 format 在父类的时候限制返回的 string ，所以我们也需要在返回值限定那 string</p></blockquote><blockquote><p>参考地址：</p><p><a href="https://www.jianshu.com/p/b8e0ef4ef249" target="_blank" rel="noopener">https://www.jianshu.com/p/b8e0ef4ef249</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-日志操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Composer</title>
      <link href="/2019/09/06/Composer/"/>
      <url>/2019/09/06/Composer/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>先了解一下历史，从拷贝第三方代码到项目中(1994)，到 PEAR 安装依赖包(1999)，再到 Composer 兴起(2012)，PHP 社区经历了将近 20 年的探索。PHP 这门古老的语言，也在不断的发展更新，在 Web 领域一直发光发热。 Composer 作为目前 PHP 包依赖管理的最佳工具，值得每一位 PHP 开发人员掌握。</p><h3 id="中文官网"><a href="#中文官网" class="headerlink" title="中文官网"></a>中文官网</h3><p><a href="https://www.phpcomposer.com/" target="_blank" rel="noopener">https://www.phpcomposer.com/</a></p><h3 id="什么是-Composer-？"><a href="#什么是-Composer-？" class="headerlink" title="什么是 Composer ？"></a>什么是 Composer ？</h3><p>是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会自动帮你安装这些依赖的库文件。</p><h3 id="扩展和包"><a href="#扩展和包" class="headerlink" title="扩展和包"></a>扩展和包</h3><p>拓展和包是两个非常相近的概念。在 PHP 世界里，一般可以这样理解和区分两者：拓展（extension）和模块（module）等价，是用 C 语言写的功能合集。</p><p>包（package）和库（library）等价，主要是用 PHP 实现的功能合集；拓展以动态链接库（.dll或.so）的形式加载，包则是通过 require/include 方式加载。绝大部分时候，两者混用不会造成理解上的困难。</p><p>常见的拓展：GD、ZIP 、Memcached 、MySQLi 、 Redis 等 </p><p>常见的包：PHPMailer 、PHPOffice 、HTMLPurifier 等</p><h3 id="PEAR-与-PECL"><a href="#PEAR-与-PECL" class="headerlink" title="PEAR 与 PECL"></a>PEAR 与 PECL</h3><p>在 Composer 流行之前，PEAR 和 PECL 是更为 PHP 开发者所知的两个工具（社区）。PEAR 是 PHP 拓展和应用仓库（PHP Extension and Application Repository）的缩写，官网<a href="http://pear.php.net/" target="_blank" rel="noopener">http://pear.php.net</a>；PECL 是 PHP 拓展社区库（PHP Extension Community Library）的缩写，官网<a href="http://pecl.php.net/" target="_blank" rel="noopener">http://pecl.php.net</a>。</p><p>两者的区别可用拓展和包来区分：PECL 托管拓展，源代码多为 C 文件，例如 APC、AMPQ 等；PEAR 托管包，功能用 PHP 实现，如 PHP CodeSniffer、HTTP Request 等；PEAR 对应 pear 命令， PECL 对应 pecl 命令，可用这两个命令安装和管理拓展和包（ pear 的 build/pickle 子命令也可以编译 PECL 中的拓展）。两者互为补充，官网以姐妹（sisters）形容两者的关系。</p><p>PECL 是官方拓展的补充，目前仍处于活跃状态，一些优秀的拓展有成为官方拓展的潜质。韩天峰大神的 swoole 拓展也托管在 PECL 中，国内名气非常高。相比之下 PEAR 已是明日黄花。PEAR2 和 Pyrus（下一代的PEAR 包安装工具，基于 PHP5.3+ 构建，官网<a href="http://pear2.php.net/" target="_blank" rel="noopener">http://pear2.php.net</a>）的出现也未能挽救 PEAR 。PEAR 没落伴随着本文主角 Composer 的兴起。</p><p>PEAR 的定位是“提供可复用的 PHP 组件”，以中心化的方式为开发者提供功能包。中心化发布的方式保证了代码的质量，同时带来维护上的不便：通过评审的包才能发布，包过时现象严重。PEAR 安装的包是全局的，不能为单独项目安装依赖包，非特权用户不能自行安装依赖包。其他缺点还包括糟糕的依赖管理。随着 Github 的流行和 Composer 的出现，包管理进入 Composer 时代。PEAR 已经完成其历史使命，可以安心的去了。</p><h3 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h3><p>严格来说，Composer 的定位是依赖管理工具而非包管理器。Composer 中文网对 Composer 工作介绍如下。Composer 将这样为你解决问题：</p><p>a) 你有一个项目依赖于若干个库。</p><p>b) 其中一些库依赖于其他库。</p><p>c) 你声明你所依赖的东西。</p><p>d) Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。</p><p>PEAR 能做的事情，Composer 都能做（包括安装 PECL 拓展），部分还能做得更好。Composer 默认把包安装在项目目录下，普通用户就能正常使用（ Composer 官方建议不要以 root 身份执行 Composer 命令）；鼓励遵循最佳实践（即大名鼎鼎的 PSR 规范，详情见 PHP-FIG 官网<a href="https://www.php-fig.org/" target="_blank" rel="noopener">https://www.php-fig.org</a>），极大的推动 PHP 社区编码风格的规范化；Composer 是去中心化的平台，任何人均可发布代码包；发布包无需评审，包的质量由用户投票决定…作为 PEAR 的继任者，Composer 的表现经受住了社区的考验，并成为事实上的依赖管理标准工具。</p><p>Composer 目前已经形成庞大的生态，在数量上，Composer 的包远超 PEAR 。由于任何人均可自由发布包且无需评审，Composer 生态中的包可能存在代码质量参差不齐、代码风格各异、后门漏洞等隐忧。另外 Composer 的依赖管理以项目为单位，一台机器上可能多次安装同一个包。但瑕不掩瑜，总体而言，Composer 极大的改变了 PHP 的开发生态，促进了代码交流和社区发展。</p><h3 id="Composer-用法"><a href="#Composer-用法" class="headerlink" title="Composer 用法"></a>Composer 用法</h3><p>Composer 为管理的项目的依赖而生，项目中的 composer.json 文件是其工作的依据。该文件中最重要的部分是 require 部分，该部分告诉 Composer 期望安装的<strong>包及其版本</strong>，例如：</p><pre><code>{    &quot;name&quot;: &quot;tinywan/easy-live&quot;,    &quot;description&quot;: &quot;nginx live module&quot;,    &quot;type&quot;: &quot;library&quot;,    &quot;license&quot;: &quot;MIT&quot;,    &quot;authors&quot;: [        {            &quot;name&quot;: &quot;Tinywan&quot;,            &quot;email&quot;: &quot;756684177@qq.com&quot;        }    ],    &quot;require&quot;: {        &quot;php&quot;: &quot;&gt;=7.0&quot;    },    &quot;autoload&quot;: {        &quot;psr-4&quot;: {            &quot;live\\&quot;: &quot;src&quot;        }    }}</code></pre><p>用 Lravel 的 composer.json  演示：</p><p><img src="https://i.loli.net/2020/02/16/7aY8NL5EqGxQ3yh.png" alt="2020-02-16_13-43.png"></p><p> 然后运行 composer install 命令，Composer 会自动分析依赖，安装最合适的包到 vendor 目录下。加 -v (-vv, -vvv)选项会打印命令执行过程中的详细信息。安装完毕后，vendor 目录下会生成 autoload.php 文件。在项目的入口文件中包含此文件： <strong>require DIR . “/vendor/autoload.php”</strong>;，接下来便可在项目的任何地方引用依赖包中的接口和类。</p><p>除 install 命令，Composer 提供了许多其他命令管理依赖。常用的命令场景包括：查找依赖、引入依赖、安装依赖、更新依赖。分别对应的命令是：</p><table><thead><tr><th align="center">命令</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">composer search</td><td align="center">根据关键字查找依赖包</td></tr><tr><td align="center">composer request</td><td align="center">引入依赖，声明项目或者全局( global，用户名全局，非系统全局)依赖某个包</td></tr><tr><td align="center">composer install</td><td align="center">安装 composer.json 声明的依赖包，最终安装的依赖包版本可能取决于有无 composer.lock 文件</td></tr><tr><td align="center">composer update</td><td align="center">更新依赖到最新版本，相当于删除 composer.lock 文件后执行 composer install</td></tr><tr><td align="center">composer info</td><td align="center">查看安装的依赖包信息，与 composer show 等价</td></tr><tr><td align="center">composer dumpautoload</td><td align="center">加 -o 选项可导出优化的加载器</td></tr><tr><td align="center">composer why(-not)</td><td align="center">查看（不）安装某个包的原因</td></tr></tbody></table><h3 id="Composer-加速"><a href="#Composer-加速" class="headerlink" title="Composer 加速"></a>Composer 加速</h3><p>有的时候会因为各种原因，我们使用 Composer 的时候回感觉安装的特别慢，网络问题是一个方面，我们可以使用一些国内的镜像来解决网络的问题，但是依然有些慢，因为 Composer 是单进程方式下载的，也就是说 Composer 安装完一个依赖，才回去下载并安装另一个依赖，任何网络问题都会让这个进程卡主。那么有没有一种方法让 Composer 并发下载所有依赖呢，这样整体安装速度不就会快很多吗？</p><p><a href="https://github.com/hirak/prestissimo" target="_blank" rel="noopener">hirak/prestissimo</a> 就是利用这个思路来加速 Composer 的，看一下这个包的描述 ——composer parallel install plugin （Composer 并行安装插件）。</p><pre><code>composer global require hirak/prestissimo</code></pre><p>切换国内阿里云镜像</p><p><a href="https://developer.aliyun.com/composer" target="_blank" rel="noopener">https://developer.aliyun.com/composer</a></p><pre><code>composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</code></pre><h3 id="Composer-加载机制"><a href="#Composer-加载机制" class="headerlink" title="Composer 加载机制"></a>Composer 加载机制</h3><p>使用 Composer 最大的好处是只需最开始 require 一个 autoload.php 文件，就可以 new 你所需要的类了，不再需要传统的方式 A 文件内各种 include 跳到 B 文件又各种 include，非常头疼。</p><p>Composer 的核心就是二个函数：spl_autoload_register 与 require_once</p><p>spl_autoload_register — 注册给定的函数作为 __autoload 的实现</p><p><strong>说明</strong></p><pre><code>spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] ) : bool</code></pre><p>将函数注册到 SPL __autoload 函数队列中。如果该队列中的函数尚未激活，则激活它们。</p><p>如果在你的程序中已经实现了<a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 函数，它必须显式注册到<a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 队列中。因为  <strong>spl_autoload_register()</strong> 函数会将 Zend Engine 中的<a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 函数取代为 <a href="https://www.php.net/manual/zh/function.spl-autoload.php" target="_blank" rel="noopener">spl_autoload()</a> 或<a href="https://www.php.net/manual/zh/function.spl-autoload-call.php" target="_blank" rel="noopener">spl_autoload_call()</a>。</p><p>如果需要多条 autoload 函数，<strong>spl_autoload_register()</strong> 满足了此类需求。 它实际上创建了 autoload 函数的队列，按定义时的顺序逐个执行。相比之下， <a href="https://www.php.net/manual/zh/function.autoload.php" target="_blank" rel="noopener">__autoload()</a> 只可以定义一次。</p><p>注意：__autoload() 函数在 PHP7.2 以后就不支持了。综合起来该用那个明白来吧。</p><p>一个简单的自动加载：</p><pre><code>// loadclass函数不具备自动加载类的功能function loadclass($classname){    $filename = &quot;./class/&quot;.$classname.&quot;.class.php&quot;;    if(is_file($filename)){        include $filename;    }}// spl_autoload_register()函数让这个 loadclass 具备了自动加载类的功能spl_autoload_register(&quot;loadclass&quot;);</code></pre><p>不使用 Composer 的代码执行会比使用 Composer 的代码执行更快，Composer 是自动加载，尽管是不用的库。这个效率毕竟大概是在几十ms的差距。我们可以优化自动加载，做一个项目 Composer 优化提速。</p><pre class="line-numbers language-php"><code class="language-php">composer dumpautoload <span class="token operator">-</span>o<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此命令不止针对于 Laravel 程序，适用于所有使用 <code>composer</code> 来构建的程序。此命令会把 <code>PSR-0</code> 和 <code>PSR-4</code> 转换为一个类映射表，来提高类的加载速度。</p><p>当然作为 艺术家的框架，Laravel 也为我们提供了 Composer 的优化处理</p><pre class="line-numbers language-php"><code class="language-php"><span class="token shell-comment comment"># 官方解释：缓存框架引导文件</span>php artisan optimize<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>参考地址</p><p><a href="https://www.cnblogs.com/tinywan/p/8855236.html" target="_blank" rel="noopener">https://www.cnblogs.com/tinywan/p/8855236.html</a></p><p><a href="https://learnku.com/courses/laravel-package/2019/hirakprestissimo/1695" target="_blank" rel="noopener">https://learnku.com/courses/laravel-package/2019/hirakprestissimo/1695</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Composer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Composer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP入门到精通</title>
      <link href="/2019/09/04/PHP%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
      <url>/2019/09/04/PHP%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<blockquote><p>闲得无所事事，觉得净下心来整理整理 PHP 的 Wiki 文档。所有资料均来至于：</p><p><a href="https://learnku.com/php/wikis" target="_blank" rel="noopener">LearnKu PHP 社区</a></p><p>最近很忙 很忙。。。</p></blockquote><h1 id="PHP-语言基础"><a href="#PHP-语言基础" class="headerlink" title="PHP 语言基础"></a>PHP 语言基础</h1><h3 id="PHP-的诞生"><a href="#PHP-的诞生" class="headerlink" title="PHP 的诞生"></a>PHP 的诞生</h3><p>PHP（外文名：PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一门开源脚本语言，专为『动态 Web 开发』而生。</p><p>PHP 于 1994 年由 Rasmus Lerdorf 创建。1995 年 6 月，PHP 1.0 发布。</p><h3 id="PHP-擅长的领域"><a href="#PHP-擅长的领域" class="headerlink" title="PHP 擅长的领域"></a>PHP 擅长的领域</h3><p>网站开发是 PHP 一直专注的领域，你可以用他来做动态网页开发，或者开发手机 App 的服务器后端接口，或者构建公司内部的 CRM 客户管理系统。拿 C 可以给 PHP 写扩展库，除去 Web 其实 PHP 还可以干很多的事情。</p><blockquote><p><a href="https://www.zhihu.com/question/67180780/answer/251574912" target="_blank" rel="noopener">https://www.zhihu.com/question/67180780/answer/251574912</a></p><p><a href="https://segmentfault.com/q/1010000008246775" target="_blank" rel="noopener">https://segmentfault.com/q/1010000008246775</a></p><p>了解一下即可，因为我们专注 ·「Web 开发」因为专注所以专业！！！</p></blockquote><h3 id="PHP-市场占有率"><a href="#PHP-市场占有率" class="headerlink" title="PHP 市场占有率"></a>PHP 市场占有率</h3><p>PHP 自诞生以来，凭借其专注 Web 开发、简单上手、容易部署等特性，在服务器脚本语言市场占有率中遥遥领先于其他对手：</p><p><img src="https://i.loli.net/2019/09/04/9dDEKsoJbRfFwkX.png" alt></p><p>上图是由 <a href="https://w3techs.com/technologies/overview/programming_language/all" target="_blank" rel="noopener">W3Techs</a> 网站提供的 <a href="https://w3techs.com/technologies/overview/programming_language/all" target="_blank" rel="noopener">服务器端脚本语言市场占有率</a> 排名，数据样本是 <a href="http://www.alexa.com/" target="_blank" rel="noopener">Alexa</a> 世界排名 <strong>前一千万</strong> 的网站，其中 79.0% 使用 PHP 构建，此数据每日更新。可看出世界上大部分的商业网站在使用 PHP。</p><h3 id="PHP-语言特性"><a href="#PHP-语言特性" class="headerlink" title="PHP 语言特性"></a>PHP 语言特性</h3><p>PHP 的特性包括：</p><ol><li>PHP 独特的语法混合了 C、Java、Perl 以及 PHP 自创新的语法；</li><li>PHP 是将程序嵌入到 HTML 文档中去执行，执行效率比完全生成 HTML 标记的 CGI 要高许多。PHP 具有非常强大的功能，所有的 CGI 的功能 PHP 都能实现；</li><li>PHP 支持几乎所有流行的数据库以及操作系统；</li><li>PHP 可以用 C、C++ 进行程序的扩展；</li><li>PHP 具备所有面对对象的特性。</li></ol><h3 id="PHP-作者"><a href="#PHP-作者" class="headerlink" title="PHP 作者"></a>PHP 作者</h3><p><img src="https://i.loli.net/2019/09/04/q5WcoKaIXfrSPd6.png" alt></p><p>PHP 语言的三位著名核心开发者：</p><ul><li>Rasmus Lerdorf，PHP 语言之父；</li><li>Andi Gutmans，创立了 Zend Technologies 并于 2016 年 2 月离开 Zend Technologies ，AWS 的总经理；</li><li>Zeev Suraski，与 Andi Gutmans 共同开发了 Zend Engine，与 Andi Gutmans 共同创立了 Zend Technologies，Zend Technologies 的首席技术官。并于 2019 年 8 月 1 日宣布离职。随后提出了 p++ 详见<ul><li><a href="https://learnku.com/php/t/32413" target="_blank" rel="noopener">p++ 中文翻译</a></li></ul></li></ul><h3 id="PHP-开发团队"><a href="#PHP-开发团队" class="headerlink" title="PHP 开发团队"></a>PHP 开发团队</h3><p>PHP 的开发管理由 Zend Technologies 公司负责，该公司设立在以色列，主要研发 Zend 相关产品，有 Zend Server、Zend Studio、Zend Framework，Zend Engine 及 Zend 认证 PHP 工程师测试 等。</p><p>Zend 认证 PHP 工程师测试旨在证明一个人完全有资格开发 PHP Web 应用程序，有兴趣的同学可报名参加，详见</p><ul><li><a href="http://www.zend.com/en/services/certification/php-certification" target="_blank" rel="noopener">PHP Certification</a></li></ul><h3 id="PHP-版本"><a href="#PHP-版本" class="headerlink" title="PHP 版本"></a>PHP 版本</h3><table><thead><tr><th align="center">主要版本</th><th align="center">发布日期</th><th align="center">相关内容</th><th align="center">结束支持日期</th></tr></thead><tbody><tr><td align="center">1.0</td><td align="center">1995-06-08</td><td align="center">有着类似 Perl 的变量命名方式、窗体处理功能 以及嵌入到 HTML 中运行的能力</td><td align="center">不详</td></tr><tr><td align="center">2.0</td><td align="center">1996-04-16</td><td align="center">速度更快、体积更小，更容易产生动态网页</td><td align="center">不详</td></tr><tr><td align="center">3.0</td><td align="center">1998-06-06</td><td align="center">开发方式改成多人共同参与。Zeev Suraski 和 Andi Gutmans 为这个版本重写了剖析引擎</td><td align="center">2000-10-20</td></tr><tr><td align="center">4.0</td><td align="center">2000-05-22</td><td align="center">改成以 Zend 引擎作为语法分析器，具有两阶 段剖析 / 标签剖析系统等先进功能</td><td align="center">2001-06-23</td></tr><tr><td align="center">4.1</td><td align="center">2001-12-10</td><td align="center">加入 “超全局变量”（superglobals）功能， 包含了 <code>$_GET</code>、<code>$_POST</code>、<code>$_SESSION</code> 等</td><td align="center">2002-03-02</td></tr><tr><td align="center">4.2</td><td align="center">2002-04-22</td><td align="center">默认取消 register_globals 功能。从网络接 收的数据将不会设置成全局变量，增加程 序安全性</td><td align="center">2002-09-06</td></tr><tr><td align="center">4.3</td><td align="center">2002-12-27</td><td align="center">加入命令行可执行文件，称为 CLI，用以 补充 CGI</td><td align="center">2005-03-31</td></tr><tr><td align="center">4.4</td><td align="center">2005-07-11</td><td align="center">为 phpize 和 PHP 配置脚本添加手册</td><td align="center">2008-08-08</td></tr><tr><td align="center">5.0</td><td align="center">2004-07-13</td><td align="center">推出有着新的对象模型的 Zend Engine II， 这也意味着 PHP 编程跨入了新时代，PHP  从此可以面向对象编程</td><td align="center">2005-09-05</td></tr><tr><td align="center">5.1</td><td align="center">2005-11-24</td><td align="center">在往重新设计的 PHP 引擎引入编译变量时 做了性能提升。添加了 PHP 数据对象（PDO） 作为访问数据库的统一接口</td><td align="center">2006-08-24</td></tr><tr><td align="center">5.2</td><td align="center">2006-11-02</td><td align="center">默认打开 “Filter” 扩展。本地支持 JSON</td><td align="center">2011-01-06</td></tr><tr><td align="center">5.3</td><td align="center">2009-06-30</td><td align="center">支持命名空间，使用 XMLReader 和 XMLWriter，支持 SOAP，延迟静态绑定， 跳转标签（有限的 goto），闭包</td><td align="center">2014-08-14</td></tr><tr><td align="center">5.4</td><td align="center">2012-03-01</td><td align="center">支持 Trait、简短数组表达式，加入了内建的 Web 服务器。增强了性能，减小内存使用量</td><td align="center">2015-09-03</td></tr><tr><td align="center">5.5</td><td align="center">2013-06-20</td><td align="center">支持 generators，用于异常处理的 finally ， 将 OpCache（基于 Zend Optimizer+）加入官方 发布中</td><td align="center">2016-07-10</td></tr><tr><td align="center">5.6</td><td align="center">2014-08-28</td><td align="center">支持常量标量表达式、可变参数函数、 指数运算符，增加 phpdbg SAPI、统一的默认字符集</td><td align="center">2018-12-31</td></tr><tr><td align="center">7.0</td><td align="center">2015-12-03</td><td align="center">Zend Engine 3 (性能提升并在 Windows 上 支持 64-bit 整数)，统一的变量语法， 基于 抽象语法树编译过程</td><td align="center">2018-12-03</td></tr><tr><td align="center">7.1</td><td align="center">2016-12-01</td><td align="center">void 返回值类型，类常量可见性修饰符</td><td align="center">2019-12-01</td></tr><tr><td align="center">7.2</td><td align="center">2017-11-30</td><td align="center">转换对象 / 数组强制转换中的数字键，计算 不可数对象，对象类型提示，删除  Mcrypt 扩展，新的 Sodium 扩展</td><td align="center">2019-12-01</td></tr><tr><td align="center">7.3</td><td align="center">2018-12-06</td><td align="center">改进了 PHP GC，重新设计了用 PHP 编写的 旧的 ext_skel 程序等</td><td align="center">未知</td></tr></tbody></table><h3 id="PHP-的发行计划"><a href="#PHP-的发行计划" class="headerlink" title="PHP 的发行计划"></a>PHP 的发行计划</h3><table><thead><tr><th>版本</th><th>发布日期</th><th>终止维护</th></tr></thead><tbody><tr><td>7.0</td><td>2015-12-3</td><td>2018-12-3</td></tr><tr><td>7.1</td><td>2016-12-1</td><td>2019-12-1</td></tr><tr><td>7.2</td><td>2017-11-30</td><td>2020-11-30</td></tr><tr><td>7.3</td><td>2018-12-6</td><td>2021-12-6</td></tr><tr><td>7.4</td><td>2019-11-21（计划）</td><td>2022-12</td></tr><tr><td>8.0</td><td>2020 Q4 或 2021 Q1</td><td>2023 Q4 或 2024 Q1</td></tr></tbody></table><p>官方有给出发布计划，可以看出基本上是每年第四季度（Q4）发布版本。</p><h3 id="PHP-的维护周期"><a href="#PHP-的维护周期" class="headerlink" title="PHP 的维护周期"></a>PHP 的维护周期</h3><p>每个版本一般的支持周期为 3 年左右。</p><blockquote><p>最近开始忙了，慢慢整理当中。。。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP入门到精通 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-存储引擎</title>
      <link href="/2019/08/21/MySQL%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/08/21/MySQL%E4%B9%8B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>MySQL 当中最最常用的存储引擎- Myisam 和 Innodb，他们二兄弟是 MySQL 当中最最常用的二个存储引擎了。当然 MySQL 的存储引擎不止他们二兄弟还有别的一些存储引擎，本着<strong>既存在即合理的原则</strong>，我们不能单方面的去评价谁好谁不好，只能说他们在不同的场景当中发挥的功力不同。那什么是存储引擎呢？</p></blockquote><p>首先我们要晓得 MySQL 的数据属于持久化存储的，表里面的数据最终都是存储在磁盘当中的，具体如何存储的，这个无需我们关心，但是要清楚存储的方式有很多种；好比一部电影，在硬盘上可以有不同的存储格式（比如：MP4、wmv、avi、rmvb、flv），它们所占的空间与清晰程度都是不一样的。</p><p>存储引擎说白了就是如何存储数据、如何为存储的数据建立索引、如何更新查询数据、如何删除数据等等技术的实现方法。引擎不同，组织处理数据的方式就不同，在关系型数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）注意：表有引擎，而库是没有引擎。</p><blockquote><p>在 Oracle 和 SQL Server 等数据库中只有一种存储引擎，所有数据存储管理机制都是一样的而 MySQL 数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g6ay8oo1rdj21fo0u0gsd.jpg" alt></p><h2 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h2><blockquote><p>5.5之前的版本默认的存储引擎就是 Myisam  ， Myisam 应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高。只考虑性能方面上来说 Innodb 完全比不上 Myisam 。</p><p>特点：不支持事务，不支持外键，并非处理稍差，支持压缩机制，支持表锁。</p></blockquote><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>Myisam 表是独立于操作系统的，这说明可以轻松地将其从 Windows 服务器移植到 Linux 服务器；每当我们建立一个 Myisam 引擎的表时，就会在本地磁盘上建立三个文件，详见</p><ul><li>*.FRM，存储表结构；</li><li>*.MYD，存储数据；</li><li>*.MYI，存储索引。</li></ul><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g69qbeiumtj20zw0lljw9.jpg" alt></p><p>① 静态 MyISAM ：<br>如果数据表中的各数据列的长度都是预先固定好的，即定长字段 char int float double ，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高，并且容易缓存。当数据受损时，恢复工作也比较容易做</p><p>缺点是占用的空间通常比动态表多。静态表在数据存储时会根据列定义的宽度补足空格，但在访问的时候并不会得到这些空格，这些空格在返回给应用之前就已经去掉了。如果你需要返回字段后的空格，这种表类型就不可取</p><p>② 动态 MyISAM ：<br>如果数据表中出现 varchar、text 或 blob decimal  等变长字段时，服务器将自动选择这种表类型。相对于静态 MyISAM，这种表存储所占的空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用 optimize table 命令或优化工具来进行碎片整理，并且出现故障的时候恢复相对比较困难</p><p>③ 压缩 MyISAM ：<br>以上说到的两种类型的表都可以用 myisamchk 工具压缩。这种类型的表进一步减小了占用的存储空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先进行解压缩</p><h3 id="排列顺序"><a href="#排列顺序" class="headerlink" title="排列顺序"></a>排列顺序</h3><blockquote><p>Myisam  存储数据时不会按照主键 ID 值进行排序存储。该特点导致 Myisam 写入特别的快。</p></blockquote><h3 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><blockquote><p>Myisam 如果进行并发写入时，MySQL 会自动加锁保证数据的一致性，而 Myisam 加的是表锁。表锁会影响到整个数据表的操作。并发性稍微逊色。</p></blockquote><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>MyISAM 表无法处理事务，这就意味着有事务处理需求的表，不能使用 MyISAM 存储引擎。<br>MyISAM 存储引擎特别适合在以下几种情况使用：</p><ul><li>选择密集型的表：MyISAM 存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li><li>插入密集型的表：MyISAM 的并发插入特性允许同时选择和插入数据。例如：MyISAM 存储引擎很适合管理邮件或 Web 服务器日志数据。</li><li>对事务完整性没有要求或者以 SELECT、INSERT 为主的应用基本都可以使用这个引擎来创建表。</li></ul><h2 id="Innodb"><a href="#Innodb" class="headerlink" title="Innodb"></a>Innodb</h2><blockquote><p>在 MySQL 5.5 之后官方默认的存储引擎就是 Innodb， Innodb 提供事务和崩溃修复能力和支持外键。 Innodb 支持行锁还支持表锁。Innodb 不保持表的具体行数，他要扫描全表来计算行数，但是使用了 where 之后呢就跟 Myisam 一样。Innodb 文件格式不支持跨平台。表主键如果没有设定主键或者非空唯一索引，就会自动生成一个 6 字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。只要不是批量插入与查询其实与 Myisam 性能上差距不是很大。而且 Innodb 安全性上更优支持很多高级功能。</p><p>特点：支持事务，支持行锁，支持外键</p></blockquote><h3 id="存储方式-1"><a href="#存储方式-1" class="headerlink" title="存储方式"></a>存储方式</h3><p> Innodb 在 5.6 版本之前使用的共享存储，所有的表的数据和索引都存储在一个文件当中，文件名为 Inbdata1 。这样的共享存储的缺点就是所有表存储的索引和数据都存放在一个文件当中，表删除了，空间还没有及时释放掉，空间尺寸越大，带来的影响就是查询和添加速度变慢，因为都存在放一个文件中。另外如果此文件有所损坏，则 MySQL 中的所有的库数据都会不存在了。在 5.6 之后采用的独立空间存储，每个表的都是独立的存在。独立存储的好处每个 Innodb 引擎存储的索引与数据都存在每个独立的文件，因为每个表都是独立存储，插入语查询数据的压力小于共享存储，且如果不小心删除了存储文件那么顶多也就是一个表会受到影响。注意：<strong>在备份数据的时候不能直接复制可能会出现很多问题，备份数据的时候应当 mysqldump 注意如果数据量很大的话导出真的太费劲了</strong></p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g6b16cawn8j21fo0u0qf3.jpg" alt></p><h3 id="排序顺序"><a href="#排序顺序" class="headerlink" title="排序顺序"></a>排序顺序</h3><blockquote><p> Innodb <strong>数据的写入顺序与数据存储顺序不一致</strong>，Innodb 会把数据按<strong>主键顺序排列</strong>，速度会比Myisam 慢一些。 Myisam 是数据怎么写入那么数据就怎么存储排列。</p></blockquote><h3 id="并发处理-1"><a href="#并发处理-1" class="headerlink" title="并发处理"></a>并发处理</h3><blockquote><p> Innodb 擅长处理并发，<strong>行级锁定</strong>，实现了行级锁定，在一定情况下可以选择行级锁定来提升并发性，也<strong>支持表级锁定</strong>，根据操作选择，<strong>只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</strong></p></blockquote><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>更新密集的表：InnoDB 存储引擎特别适合处理多重并发的更新请求</p><p>事务：InnoDB 存储引擎是支持事务的标准 MySQL 存储引擎</p><p>自动灾难恢复：与其它存储引擎不同，InnoDB 表能够自动从灾难中恢复</p><p>外键约束：MySQL 支持外键的存储引擎只有 InnoDB</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是 MySQL 在服务器层和存储引擎层的的并发控制。</p><p>加锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已解除、释放锁等。</p></blockquote><p>锁只支持一种特性，而事务支持四中。</p><p>一般来说，事务是必须满足4个条件（ACID）：：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><pre><code>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</code></pre><h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><p>共享锁(读锁)：其他事务可以读，但是不能写。</p><p>排他锁(写锁)：其他事务不可以读，也不可以写。</p><h3 id="颗粒锁"><a href="#颗粒锁" class="headerlink" title="颗粒锁"></a>颗粒锁</h3><p>Mysql 不同的存储引擎支持不同的锁机制，所有的存储引擎都以自己的方式显示了锁机制，服务器层完全不了解存储引擎中的锁实现：</p><ul><li>MyISAM 和 MEMORY 存储引擎采用的是表级锁（table-level locking）</li><li>BDB 存储引擎采用的是页面锁（page-level locking），但也支持表级锁</li><li>InnoDB 存储引擎既支持行级锁（row-level locking），也支持表级锁，但默认情况下是采用行级锁。</li></ul><table><thead><tr><th align="center">锁</th><th align="center">加锁效率</th><th align="center">是否会死锁</th><th align="center">颗粒</th><th align="center">冲突</th><th align="center">并发</th></tr></thead><tbody><tr><td align="center">表级锁</td><td align="center">开销小，加锁快</td><td align="center">不会出现死锁</td><td align="center">锁定粒度大</td><td align="center">发生锁冲突的概率最高</td><td align="center">并发度最低</td></tr><tr><td align="center">行级锁</td><td align="center">开销大，加锁慢</td><td align="center">会出现死锁</td><td align="center">锁定颗粒最小</td><td align="center">发送锁冲突的概率最低</td><td align="center">并发度最高</td></tr><tr><td align="center">页面锁</td><td align="center">开销和加锁时间界于表锁和行锁之间</td><td align="center">会出现死锁</td><td align="center">锁定粒度界于表锁和行锁之间</td><td align="center">发送锁冲突的概率一般</td><td align="center">并发度一般</td></tr></tbody></table><p>默认情况下，表锁和行锁都是自动获得的， 不需要额外的命令。</p><p>但是在有的情况下， 用户需要明确地进行锁表或者进行事务的控制， 以便确保整个事务的完整性，这样就需要使用事务控制和锁定语句来完成。</p><h3 id="不同颗粒锁的比较"><a href="#不同颗粒锁的比较" class="headerlink" title="不同颗粒锁的比较"></a>不同颗粒锁的比较</h3><ul><li>表锁<ul><li>这些存储引擎通过总是一次性同时获取所有需要的锁以及总是按相同的顺序获取表锁来避免死锁</li><li>表级锁更适合于以查询为主，并发用户少，只有少量按索引条件更新数据的应用，如 Web 应用</li></ul></li><li>行锁<ul><li>最大程度的支持并发，同时也带来了最大的锁开销。</li><li>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，这就决定了在 InnoDB 中发生死锁是可能的。</li><li>行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现。 行级锁更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统</li></ul></li></ul><h3 id="Myisam-表级锁模式"><a href="#Myisam-表级锁模式" class="headerlink" title="Myisam 表级锁模式"></a>Myisam 表级锁模式</h3><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>Myisam 表的读操作与写操作之间，以及写操作之间是串联的。<strong>当一个线程获得对一个表写锁后，只有持有锁的线程可以进行表的更新操作。其他线程的读、写都会等待，直到锁被释放为止。</strong></p><p>默认情况下，写锁比读锁具有更高的优先级。当一个锁释放的时候，这个锁会优先给写锁队列中等候的获取锁请求，然后才会给读锁队列中等候的获取锁请求。这也正是 Myisam 表不太适合有大量更新操作的和查询操作应用的原因。因为大量的更新操作会导致查询操作很难获得读锁，从而可能导致永远阻塞。同时一些需要长时间运行的查询操作，也会使写线程“饿死”应用当中应当避免长时间的查询操作（在可能的情况下可以通过使用中间表等措施对SQL 语句做一定的“分解” ，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行）。</p><p>可以设置改变读锁和写锁的优先级：</p><ul><li>通过指定启动参数 low-priority-updates，使 MyISAM 引擎默认给予读请求以优先的权利。</li><li>通过执行命令 SET LOW_PRIORITY_UPDATES=1，使该连接发出的更新请求优先级降低。</li><li>通过指定 INSERT、UPDATE 、DELETE 语句的 LOW_PRIORITY 属性，降低该语句的优先级。<br>给系统参数 max_write_lock_count 设置一个合适的值，当一个表的读锁达到这个值后，MySQL 就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ul><h3 id="Myisam加表锁方法"><a href="#Myisam加表锁方法" class="headerlink" title="Myisam加表锁方法"></a>Myisam加表锁方法</h3><p>Myisam 在执行查询语句 select 前，会自动给涉及的表加读锁。</p><p>Myisam 在执行更新操作 update dalete insert 前，会自动给涉及的表加写锁。</p><blockquote><p>这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 Myisam 表显式加锁。</p><p>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，这也正是 MyISAM 表不会出现死锁（Deadlock Free）的原因。</p></blockquote><p>MyISAM 存储引擎支持并发插入，以减少给定表的读和写操作之间的争用：</p><p>如果 MyISAM 表在数据文件中间没有空闲块，则行始终插入数据文件的末尾。 在这种情况下，你可以自由混合并发使用 MyISAM 表的 INSERT 和 SELECT 语句而不需要加锁——你可以在其他线程进行读操作的时候，同时将行插入到 MyISAM 表中。 文件中间的空闲块可能是从表格中间删除或更新的行而产生的。 如果文件中间有空闲快，则并发插入会被禁用，但是当所有空闲块都填充有新数据时，它又会自动重新启用。 要控制此行为，可以使用 MySQL 的 concurrent_insert 系统变量。</p><p>如果你使用 LOCK TABLES 显式获取表锁，则可以请求 READ LOCAL 锁而不是 READ 锁，以便在锁定表时，其他会话可以使用并发插入。</p><ul><li>当 concurrent_insert 设置为0时，不允许并发插入。</li><li>当 concurrent_insert 设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM 允许在一个线程读表的同时，另一个线程从表尾插入记录。这也是 MySQL 的默认设置。</li><li>当 concurrent_insert 设置为2时，无论 MyISAM 表中有没有空洞，都允许在表尾并发插入记录。</li></ul><h3 id="查询表级锁争用情况"><a href="#查询表级锁争用情况" class="headerlink" title="查询表级锁争用情况"></a>查询表级锁争用情况</h3><p>可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁的争夺，如果 Table_locks_waited 的值比较高，则说明存在着较严重的表级锁争用情况：</p><pre class="line-numbers language-mysql"><code class="language-mysql">mysql> SHOW STATUS LIKE 'Table%';+-----------------------+---------+| Variable_name | Value |+-----------------------+---------+| Table_locks_immediate | 1151552 || Table_locks_waited | 15324 |+-----------------------+---------+<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Innodb行级锁和表级锁"><a href="#Innodb行级锁和表级锁" class="headerlink" title="Innodb行级锁和表级锁"></a>Innodb行级锁和表级锁</h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><blockquote><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p></blockquote><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>锁模式的兼容情况</strong></p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g6dfpsdoulj20k006qwep.jpg" alt></p><blockquote><p>如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。</p></blockquote><h3 id="Innodb加锁方法"><a href="#Innodb加锁方法" class="headerlink" title="Innodb加锁方法"></a>Innodb加锁方法</h3><ul><li><p>意向锁是 Innodb自 动加的，不需要用户干预。</p></li><li><p>对于对于 update insert delete 语句， innodb 会自动给涉及数据集加排他锁（X)；</p></li><li><p>对于普通 select 语句 innodb 不会加任何锁。</p></li><li><p>事务可以通过以下语句显式给记录集加共享锁或排他锁：</p><ul><li>共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。</li><li>排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁</li></ul></li></ul><h3 id="InnoDB-行锁实现方式"><a href="#InnoDB-行锁实现方式" class="headerlink" title="InnoDB 行锁实现方式"></a>InnoDB 行锁实现方式</h3><ul><li>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！</li><li>不论是使用主键索引、唯一索引或普通索引，InnoDB 都会使用行锁来对数据加锁。</li><li>只有执行计划真正使用了索引，才能使用行锁：即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时，<br>别忘了检查 SQL 的执行计划（可以通过 explain 检查 SQL 的执行计划），以确认是否真正使用了索引。（更多阅读：<a href="https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s/h4B84UmzAUJ81iBY_FXNOg" target="_blank" rel="noopener">MySQL索引总结</a>）</li><li>由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然多个 session 是访问不同行的记录， 但是如果是使用相同的索引键， 是会出现锁冲突的（后使用这些索引的 session 需要等待先使用索引的session 释放锁后，才能获取锁）。 应用设计的时候要注意这一点。</li></ul><h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><ul><li><p><strong>乐观锁(Optimistic Lock)</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。</p><ul><li>乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于 write_condition 机制的其实都是提供的乐观锁。</li></ul></li><li><p><strong>悲观锁(Pessimistic Lock)</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p><ul><li>悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li></ul></li></ul><h3 id="一些优化锁性能的建议"><a href="#一些优化锁性能的建议" class="headerlink" title="一些优化锁性能的建议"></a>一些优化锁性能的建议</h3><ul><li>尽量使用较低的隔离级别；</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li>除非必须，查询时不要显示加锁。 MySQL 的 MVCC 可以实现事务中的查询不用加锁，优化事务性能； MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>索引是存储引擎用于快速找到记录的一种数据结构。如果说没有索引的话，数据库就必须重第一条记录开始进行全表扫描，直到找出相关的行。数据越多，检索的代价就越高，检索时如果表的列存在索引，那么 MySQL 就能快速到达指定位置去搜索数据文件，而不必查看所有数据。注意有些情况下，MySQL 如果觉得全表扫描来的好，那么也不会去走索引。</p><p><strong>索引是一种以空间换取时间的方式，牺牲了写的速度，提高查询速度，创建完毕索引后，写慢读快</strong></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote><p>索引依托于存储引擎的实现，因此，每种存储引擎的索引都不一定完全的相同，并且每种存储引擎也不一定支持所有的索引类型。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。大多数存储引擎有更高的额限制。</p></blockquote><p>MySQL 中索引的存储类型有两种： BTREE 和 HASH ，具体和表的存储引擎相关；</p><p>为什么我们添加完索引后查询速度为变快？</p><p>传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，MySQL 需要将表的数据从头到尾遍历一遍，在我们添加完索引之后， MySQL 一般通过 BTREE 算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历(折半查找大幅查询效率)，找到相应的键从而获取数据。</p><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>在 MySQL 索引默认有 btree 和 hash 两种类型，Myisam ,Innodb 中,默认用 btree 索引类型。</p><p>两者的区别：</p><ul><li>hash 函数计算后的结果,是随机的,如果是在磁盘上放置数据,添加的数据行在磁盘上随机放置,点对点的查询速度最快。  select name from id=1;</li><li>hash 类型不能对范围查询进行优化</li><li>无法利用前缀索引，比如 在 btree 中, 字段值 “zhangsan” ,查询 字段=“zhang”,可以利用索引,而 hash 类型则不行</li><li>排序也无法优化</li><li>通过索引拿到数据位置,必须回到表中取数据</li></ul><p>优点：</p><ul><li>加快数据的查询速度</li><li>唯一索引，可以保证数据库表中每一行数据的唯一性</li><li>在实现数据的参考完整性方面，可以加速表和表之间的连接</li><li>在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间</li></ul><p>缺点：</p><ul><li>占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸（<strong>合理运用，问题不大</strong>）</li><li>损耗性能（<strong>添加、修改、删除</strong>） 索引需要动态地维护</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><p><strong>普通索引，组合索引</strong>：<strong>对关键字没有要求</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add index 索引名称 (`创建索引的字段`); # 普通索引alter table 表名 add index 索引名称 (`创建索引的字段`,`创建索引的字段`); # 组合索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>唯一索引</strong>：<strong>要求关键字不能重复，同时增加唯一约束</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add unique index 索引名称 (`创建索引的字段`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>主键索引</strong>：<strong>要求关键字不能重复，也不能为 NULL 。同时增加主键约束</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add primary key 索引名称 (`创建索引的字段`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>全文索引</strong>：<strong>关键字的来源不是所有字段的数据，而是从字段中提取的特别关键词</strong>。</p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 add fulltext (`创建索引的内容`);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看索引</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">show index from 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除索引</strong></p><pre class="line-numbers language-mysql"><code class="language-mysql">alter table 表名 drop index 索引名;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍，高效的索引对于获得良好的性能非常重要。</p></blockquote><ol><li><p>索引并非越多越好，一个表当中如果有大量的索引，那么他还会影响到更新操作（insert、update、delete）的性能，因为当表的数据更改的同时，索引也会进行调整和更新。</p></li><li><p>避免对<strong>经常更新的表</strong>设计过多的索引，并且索引中的列尽可能要少，而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段</p></li><li><p>数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引时间还要短，索引可能不会产生优化效果</p></li><li><p>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值较少的列上不要建立索引，比如性别字段只有男和女，就没必要建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度</p></li><li><p>当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度</p></li><li><p>在频繁排序或分组（即 group by 或 order by 操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引 </p></li></ol><p>总结：<br>    较频繁的作为查询条件字段应该创建索引<br>    唯一性太差的字段不适合创建索引，尽管频繁作为查询条件，例如 gender 性别字段<br>    更新非常频繁的字段不适合作为索引<br>    不会出现在 where 子句中的字段不该创建索引</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1、 存储结构</strong></p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为.MYD (MYData)。索引文件的扩展名是.MYI (MYIndex)。<br>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p><p><strong>2、 存储空间</strong></p><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。<br>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p><p><strong>3、 可移植性、备份及恢复</strong></p><p>MyISAM：数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。<br>InnoDB：免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了。</p><p><strong>4、 事务支持</strong></p><p>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。<br>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p><p><strong>5、 AUTO_INCREMENT</strong></p><p>MyISAM：可以和其他字段一起建立联合索引。引擎的自动增长列必须是索引，如果是组合索引，自动增长可以不是第一列，他可以根据前面几列进行排序后递增。<br>InnoDB：InnoDB中必须包含只有该字段的索引。引擎的自动增长列必须是索引，如果是组合索引也必须是组合索引的第一列。</p><p><strong>6、 表锁差异</strong></p><p>MyISAM：只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。<br>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</p><p><strong>7、 表主键</strong></p><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。<br>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。</p><p><strong>8、 表的具体行数</strong></p><p>MyISAM：保存有表的总行数，如果select count(<em>) from table;会直接取出出该值。<br>InnoDB：没有保存表的总行数，如果使用select count(</em>) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p><p><strong>9、 CURD操作</strong></p><p>MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。<br>InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。</p><p><strong>10、 外键</strong></p><p>MyISAM：不支持<br>InnoDB：支持<br>通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p><p>表锁，行锁，行锁副作用（update 多时候变慢），在 select 和 update 混合的情况下，行锁巧妙解决了读写互斥的问题；</p><p>而 Innodb 由于支持行锁，所以在数据修改方面更胜一筹</p><blockquote><p>参考地址：</p><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29150809</a></p><p><a href="https://blog.csdn.net/qq_19865749/article/details/79309387" target="_blank" rel="noopener">https://blog.csdn.net/qq_19865749/article/details/79309387</a></p><p><a href="https://juejin.im/entry/5a448726f265da43062b10f1" target="_blank" rel="noopener">https://juejin.im/entry/5a448726f265da43062b10f1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-接口签名验证</title>
      <link href="/2019/08/19/Laravel%E4%B9%8B%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/"/>
      <url>/2019/08/19/Laravel%E4%B9%8B%E6%8E%A5%E5%8F%A3%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在我们实际的开发情况当中，后台在处理请求的时候是根本不知道谁请求了我们。我们不清楚来源是否合法，是否是我们允许的用户在调用我们的接口！有可能一些人乱搞我们的接口，所以综合来说我们都应该对于我们接口的访问做一些安全性的验证。laravel 中间件功能开启全局中间件后，所有访问都得走中间件，那么我们就可以利用这个特性来做一个接口安全验签的处理，自己与 前台商量下写一套验签的规则。我这里采用的就是时间戳和随机数加密做一个签名的验签。</p><pre><code>&lt;?phpnamespace App\Http\Middleware;use Closure;class ApiTokenVerify{    const TOKEN = &#39;APITOKEN&#39;;    /**     * Handle an incoming request.     *     * @param \Illuminate\Http\Request $request     * @param \Closure $next     * @return mixed     */    public function handle($request, Closure $next)    {        try{            if (!$this-&gt;apiToken(time(), $this-&gt;randomNumber(), &#39;1231231&#39;))            {                   return response()-&gt;json([                       &#39;code&#39; =&gt; 403,                       &#39;msg&#39; =&gt; &#39;没有权限&#39;                   ]);            }        }catch (\Exception $e){                 return response()-&gt;json([                     &#39;code&#39; =&gt; 500,                     &#39;msg&#39; =&gt; $e-&gt;getMessage()                 ]);        }        return $next($request);    }    /**     * 生成随机数     * */    public function randomNumber()    {        $text = &#39;qwertyuiopasdfghjklzxcvbnm1234567890&#39;;        $str = &#39;&#39;;        for ($i = 0; $i &lt;= 10; $i++) {            $str .= substr($text, mt_rand(0, strlen($text) - 1), 1);        }        return self::TOKEN . $str;    }    /**     * 生成签名     * @param string time     * @param string random     * @param string api_token     * @return bool     * */    public function apiToken(string $time, string $random, string $api_token) :bool    {        $arr[&#39;time&#39;] = $time;        $arr[&#39;random&#39;] = $random;        $arr[&#39;token&#39;] = self::TOKEN;        // 首字母大小写排序        sort($arr);        $str = implode($arr);        // md5 40位加密        $str_16 = substr(md5(&#39;admin&#39;), 0, 16);        $one = substr(md5($str), 24, 8);        $two = substr(md5($str), 16, 16);        // md5 40位加密 在sha1加密        $str = sha1($str_16 . $one . $two);        // 在全部转换成大写        $str = strtoupper($str);        // 判断前端的签名是否一直       return $api_token == $str ? true : false;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-接口验签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP+Nginx执行请求的原理</title>
      <link href="/2019/08/18/PHP-Nginx%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2019/08/18/PHP-Nginx%E6%89%A7%E8%A1%8C%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><blockquote><p>当我们访问一个 Web 站点，PHP 和 Nginx 是怎么去执行的呢？</p><p>浏览器发起请求 -&gt;  web_server(nginx)  分发处理-&gt;  PHP 执行代码返回结果</p></blockquote><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><ul><li><p>CGI<br>CGI 是 Web 服务器运行外部程序的规范。意思就是通过 CGI 可以与你的程序通信，通过 CGI 标准格式。你的程序可以和浏览器交互。</p><blockquote><p>简单理解 CGI 就是一个协议，规定了一些东西该怎么传，你的程序这边怎么接受处理等规范。</p></blockquote></li><li><p>PHP-CGI<br>PHP-CGI 就是 CGI 协议 PHP 的一个实现版。PHP-CGI 会为每个请求 fork 一个进程处理，处理完成后退出。(这个模式叫做 fork-and-execute)。这样的模式不符合现在动不动大规模的流量，所以已退出历史舞台。</p></li><li><p>FastCGI<br>FastCGI 是 CGI 的升级版，他会预先启动一个 master 进程读取配置文件，然后 fork 多个 work 进程等待连接。监听到请求，分配给 work 进程做具体的处理。这样大大提高了程序的性能。</p><blockquote><p>FastCGi 会管理进程，处理完成后不会轻易销毁。而 CGI 会为每一个请求，创建进程，销毁进程。</p></blockquote></li><li><p>PHPFPM<br>作为世界上最好的语言，当然要跟上潮流。当发现 PHP-CGI 性能不佳时，又恰好出现了 FastCGI 协议。所以 PHP 实现了一个 PHP 版本的 FastCGI，名字叫做 PHPFPM（FastCGI Process Manager）。 PHPFPM 启动时会开启 一个 master 进程和若干个 work 进程。master 进程监听请求，并转发给 work 进程处理，每一个 work 进程都有一个 PHP 解释器，你的代码在每一个 work 进程中都有一份，work 进程是真正执行代码的地方。</p></li></ul><h3 id="一次完整的流程"><a href="#一次完整的流程" class="headerlink" title="一次完整的流程"></a>一次完整的流程</h3><p>首先用户访问 Web 站点</p><p>域名进行 DNS 解析</p><p>DNS 解析完成之后，发起 TCP 协议的三次捂手</p><p>HTTP 请求对应 IP 服务器和端口</p><p>Nginx 监听到对应的端口请求之后</p><p>Nginx 会对 URL 做一个 Location 的正则匹配</p><p>如果是静态资源则返回文件，Nginx 响应 HTTP 请求</p><p>如果是动态资源，通过正则匹配到请求 PHP 脚本，那么他会通过 Nginx 的模块 ngx_http_fastcgi_module 把请求分发给 PHPFPM 处理，也就是 Nginx 配置文件当中的 fastcgi_pass=127.0.0.1:9000 这种属于网络模式</p><p>PHPFPM master 进程监听到请求之后，分配给 work 处理（每一个 work 进程中都有一个 PHP 解释器），PHPFPM 在启动的时候已经 work 进程已经加载了配置，加载了你写的代码。所以说 work 进程接收到请求后立马执行，然后 work 进程执行返回的结果给 Nginx，Nginx 响应 HTTP 请求。</p><h3 id="ngx-http-fastcgi-module-模块"><a href="#ngx-http-fastcgi-module-模块" class="headerlink" title="ngx_http_fastcgi_module 模块"></a>ngx_http_fastcgi_module 模块</h3><p>在浏览器请求 web_server 是 HTTP 协议 或者 HTTPS 协议，但是 PHPFPM 不懂怎么办了？这里 Nginx 提供了一个 ngx_http_fastcgi_module ，ngx_http_fastcgi_module 把 HTTP 或者 HTTPS 请求 映射成 FastCGI 请求。这样 PHP 程序就能和用户互动了。</p><h3 id="PHP-平滑重启原理"><a href="#PHP-平滑重启原理" class="headerlink" title="PHP 平滑重启原理"></a>PHP 平滑重启原理</h3><p>每次修改完 PHP.ini 配置并重启后，会启动新的 worker 进程加载新的配置，而之前已经存在的进程会在工作完成之后销毁，因此实现平滑重启</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</p><p>线程：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。一个程序至少一个进程，一个进程至少一个线程。</p><p><strong>进程线程的区别：</strong></p><ul><li>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</li><li>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。</li></ul><p>　　　　　一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p>　　　　　进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p><ul><li>执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>线程是处理器调度的基本单位，但是进程不是。</li><li>两者均可并发执行。</li></ul><p><strong>优缺点：</strong></p><p>　　线程执行开销小，但是不利于资源的管理和保护。线程适合在SMP机器（双CPU系统）上运行。</p><p>　　进程执行开销大，但是能够很好的进行资源管理和保护。进程可以跨机器前移。</p><p>  <strong>何时使用多进程，何时使用多线程？</strong></p><p>对资源的管理和保护要求高，不限制开销和效率时，使用多进程。</p><p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用多线程。</p><blockquote><p>参考地址：</p><p><a href="https://learnku.com/articles/32318#reply104413" target="_blank" rel="noopener">https://learnku.com/articles/32318#reply104413</a></p><p><a href="https://www.cnblogs.com/zhuzhu2016/p/5804875.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuzhu2016/p/5804875.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker搭建PHP开发环境</title>
      <link href="/2019/08/17/Docker%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2019/08/17/Docker%E6%90%AD%E5%BB%BAPHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>2010 年，几个搞 IT 的年轻人，在美国旧金山成立了一家名叫 “dotCloud” 的公司。</p><p>这家公司主要提供基于 PaaS 的云计算技术服务。具体来说，是和 LXC 有关的容器技术。</p><p>LXC 也就是 Linux 容器虚拟化技术。</p><p>后来，dotCloud 公司将自己的容器技术进行了简化和标准化，并命名为——<strong>Docker</strong>。</p><p>Docker 技术诞生之后，并没有引起行业的关注。而 dotCloud 公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了 “开源” 的想法。</p><p>什么是 “开源” ？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。</p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013 年 3 月，dotCloud 公司的创始人之一，Docker 之父，28 岁的 *<em>Solomon Hykes *</em>正式决定，将 Docker 项目开源。</p><p>不开则已，一开惊人。</p><p>越来越多的 IT 工程师发现了 Docker 的优点，然后蜂拥而至，加入 Docker 开源社区。</p><p>Docker 的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1 版本发布。此后的每一个月，Docker 都会发布一个版本。到 2014 年 6 月 9 日，Docker 1.0 版本正式发布。</p><p>此时的 Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像 Google、微软、Amazon、VMware 这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker 火了之后，dotCloud 公司干脆把公司名字也改成了 Docker Inc. 。</p><p>Docker 和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是<strong>虚拟机</strong>。虚拟机技术的代表，是 VMWare 和 OpenStack。</p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。</p><p>在“子电脑”里，你可以和正常电脑一样运行程序，例如开 QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上 QQ。“子电脑”和“子电脑”之间，是<strong>相互隔离</strong>的，互不影响。</p><p>虚拟机属于虚拟化技术。而 Docker 这样的容器技术，也是虚拟化技术，属于<strong>轻量级的虚拟化</strong>。</p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如 VMWare ）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。</p><p>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个 Docker 容器）。此外，它占的空间很小，虚拟机一般要几 GB 到几十 GB 的空间，而容器只需要 MB 级甚至 KB 级。</p><p><img src="https://i.loli.net/2020/01/15/cz6OW7Kum9NXCZH.png" alt="2020-01-15_12-03.png"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。</p><p>Docker 技术的三大核心概念，分别是：</p><ul><li><strong>镜像（Image）</strong></li><li><strong>容器（Container）</strong></li><li><strong>仓库（Repository）</strong></li></ul><p>其实在简单点来说 Docker 的好处，“在我的机器上可正常工作”的问题。 运维人员利用 Docker 可以在隔离容器中并行运行和管理应用，获得更好的计算密度。 企业利用 Docker 可以构建敏捷的软件交付管道，以更快的速度、更高的安全性和可靠的信誉为 Linux 和 Windows Server 应用发布新功能。</p><p>总结为一句话：简单，快捷，方便，一次构建，到处运行。解决了我们环境的问题（本地开发好好的，上线又乱七八糟的了）</p><p><strong>转折点</strong>：</p><p>就在 Docker 容器技术被炒得热火朝天之时，大家发现，如果想要将 Docker 应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对 Docker 及容器进行更高级更灵活的管理。K8s，诞生了！</p><h3 id="熟悉几个命令"><a href="#熟悉几个命令" class="headerlink" title="熟悉几个命令"></a>熟悉几个命令</h3><table><thead><tr><th align="center">命令</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">systemctl start docker</td><td align="center">启动 docker</td></tr><tr><td align="center">docker images</td><td align="center">查看所有镜像</td></tr><tr><td align="center">docker pull &lt;库上的镜像&gt;</td><td align="center">在 dockerhub 当中拉取镜像</td></tr><tr><td align="center">docker rmi &lt;id/名称&gt;</td><td align="center">删除镜像</td></tr><tr><td align="center">docker run -p 80 –name nginx -d nginx</td><td align="center">创建容器：p端口号 d后台运行</td></tr><tr><td align="center">docker exec -it &lt;容器名称&gt; dash</td><td align="center">进入容器</td></tr><tr><td align="center">docker ps</td><td align="center">查看所有运行容器</td></tr><tr><td align="center">docker ps -a</td><td align="center">查看所有容器</td></tr><tr><td align="center">docker rm &lt;id/名称&gt;</td><td align="center">删除容器：要先关闭容器才能删</td></tr><tr><td align="center">docker stop &lt;容器&gt;</td><td align="center">停止容器</td></tr><tr><td align="center">docker start &lt;容器&gt;</td><td align="center">启动容器</td></tr><tr><td align="center">docker restart &lt;容器&gt;</td><td align="center">重启容器</td></tr><tr><td align="center">docker cp &lt;容器名称&gt;:/&lt;容器里文件&gt;</td><td align="center">docker 复制容器文件</td></tr><tr><td align="center">docker -v &lt;本地文件&gt;:/&lt;容器里文件&gt;</td><td align="center">docker 映射文件</td></tr></tbody></table><h3 id="MySQL-安装"><a href="#MySQL-安装" class="headerlink" title="MySQL 安装"></a>MySQL 安装</h3><p>从 Dockerhub 拉取 MySQL 镜像</p><pre><code>docker pull mysql</code></pre><p>实例容器,启动数据库：</p><pre><code>docker run -p 3306:3306 --name mysql -v /xxx:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d --privileged=true mysql### 命令说明：run 创建一个容器 --name 给容器的名称 （如果留空，docker会自动分配一个名称）-v 映射文件，预留，也可以不要-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口-e MYSQL_ROOT_PASSWORD=root：初始化 root 用户的密码-d 后台运行容器--privileged=true  可能会碰到权限问题，需要加参数# 进入容器docker exec -it mysql dash # 修改密码认证 mysql 8 加密方式改变了mysql&gt;ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;;mysql&gt;flush privileges;# 创建一个帐号，并且赋予权限mysql&gt;create user &#39;用户名&#39;@&#39;访问主机&#39; identified by &#39;密码&#39;;mysql&gt;grant 权限 on *.* to &#39;帐号&#39;@&#39;%&#39; WITH GRANT OPTION;# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update# 修改 /etc/mysql/conf.d 下面的 myqsl.cnf 添加以下配置 注意配置当中的 mysql 要改为 mysqlddefault_authentication_plugin=mysql_native_password</code></pre><h3 id="PHP-FPM-安装"><a href="#PHP-FPM-安装" class="headerlink" title="PHP-FPM 安装"></a>PHP-FPM 安装</h3><pre><code>docker pull php:fpm</code></pre><p>实例容器,启动 PHP：</p><pre><code># 创建容器并且关联 MySQLdocker run --name php-fpm -p 9000:9000 --link mysql:mysql -v /宿主机存放代码的目录:/var/www/html -it -d php:fpm### 命令说明：run 创建一个新的容器--name 指定容器的名称-p 9000:9000：将容器的 9000 端口映射到主机的 9000 端口php-fpm 是 Dockerhub 上下载镜像名称（如果本地没有可用的镜像，Docker会自动下载一个）-it 表示让容器的标准输入打开,并且分配一个伪终端-d 后台启动。# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update# Composer 安装1、curl -sS https://getcomposer.org/installer | php2、mv composer.phar /usr/local/bin/composer3、composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/# 修改 php-fpm.conf include 路径include=/usr/local/etc/php-fpm.d/*.conf# 开启扩展/usr/local/bin/docker-php-ext-install pdo_mysql# 已经在包存在的扩展直接可以这样安装了，没有的就得自己下载安装了。下载扩展到 /usr/src/php/ext 目录当中,注意：如果没有 /usr/src/php/ext 别慌执行一下 /usr/local/bin/docker-php-ext-install 一个没有的扩展，然后文件夹就会有了，每次安装好扩展之后 php 自动删除！# docker-php-ext-enable 可以控制扩展# 配置 nginx FastCGI 的请求location ~ \.php$ {  root           /var/www/html/;  fastcgi_pass   php-fpm:9000;  fastcgi_index  index.php;  include        fastcgi_params;  fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name;}</code></pre><h3 id="Nginx-安装"><a href="#Nginx-安装" class="headerlink" title="Nginx 安装"></a>Nginx 安装</h3><p>从 Dockerhub 拉取 Nginx 镜像 </p><pre><code>docker pull nginx</code></pre><p>实例容器,启动 Nginx：</p><pre><code>docker run --name nginx_80 -p 80:80 --link php-fpm -v /宿主机存放代码的目录:/usr/share/nginx/html -d nginx### 命令说明run 创建一个新的容器--name 指定容器的名称-p 80:80：将容器的 80 端口映射到主机的 80 端口nginx 是 Dockerhub 上下载nginx镜像名称（如果本地没有可用的镜像，Docker会自动下载一个）-d 后台启动。# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update</code></pre><h3 id="memcached"><a href="#memcached" class="headerlink" title="memcached"></a>memcached</h3><pre><code>docker pull memcached#实例容器,启动memcached：docker run --name memcached -p 11211:11211 -m 64m -d memcached# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update#安装 memcached 的时候会去少依赖，根据下面评论安装即可搞定</code></pre><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><pre><code>docker pull redis#实例容器,启动redisdocker run --name redis -p 6379:6379  -d redis redis-server --appendonly yes# 中科大源,然后下载需要的软件sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.listapt update# redis5以后 没有配置文件，需要自己去 redis 官方下载一个想对应的版本把里面的配置文件复制出来</code></pre><p><img src="https://i.loli.net/2019/09/26/16iHMtqA8BYZEeQ.png" alt></p><p><img src="https://i.loli.net/2019/09/26/JLyaowZkuSvNzmX.png" alt></p><blockquote><p>参考地址：</p><p><a href="https://zhuanlan.zhihu.com/p/53260098" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53260098</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cookie session token</title>
      <link href="/2019/08/12/cookie-session-token-JWT/"/>
      <url>/2019/08/12/cookie-session-token-JWT/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>WEB 应用程序是使用 HTTP 协议传输数据，早期处于刚开始发展阶段时，属于文档浏览阶段（ HTTP/0.9 的时候只有文本传输，1.0 开始才支持图片、视频、二进制文件传输），不需要做交互，服务端不需要去记录先前的事务，这样服务端答复也很快（这就是 HTTP 无状态特性）。但随着 WEB 的发展，进入交互时代，这时候我们就需要跟服务端做交互了，比如我们要保持用户的登录状态而我们 HTTP 协议却办不到，因为  HTTP 协议属于无状态他对先前事务处理没有记忆的功能，一次请求完成就立马断开。通俗的来讲就是：虽然你刚才来过我这里了，但是抱歉我不记得你来过了，而你还没办法证明自己来过！这就是很尴尬了，没办法啊我们现在随着发展需要记录事务了呀，这时我们会话技术就诞生了！会话的总体思想：令牌，既然你每次都不记得我，那好我们打造一个令牌分成两半，你一半我一半合的起来那就是对的人！不过发这半块令牌给你的人，还是服务端哦！</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><blockquote><p>Cookie 是客户端使用的一种记录客户端状态的机制，是<strong>由 W3C 组织提出</strong>，最早由 Netscape(网景) 社区发展的一种机制。目前 Cookie 已经成为标准，所有的主流浏览器基本都支持 Cookie 。Cookie（也叫 Web Cookie 或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview#HTTP_is_stateless_but_not_sessionless" target="_blank" rel="noopener">无状态</a>的 HTTP 协议记录稳定的状态信息成为了可能。<strong>Cookie 实际上就是一小段文本信息</strong>。</p></blockquote><p>客户端请求服务器端，服务器端会在 HTTP 响应消息报头当中插入 Set-cookie ，存储的就是 Cookie 的值。</p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g68v87xx0pj216n0pitbs.jpg" alt></p><p>客户端就会把 Cookie 保存起来，如果 Cookie 设置了过期时间那么就属于持久存储直到过期，如果没有设置过期时间浏览器关闭即为销毁，持久存储会存储在磁盘当中，非持久存储会存储在内存当中！</p><p>客户端下次在请求服务器端的时候，会自动在请求报头当中插入 Cookie 。服务器端检测该 Cookie，以此来识别用户状态。</p><p><img src="https://i.loli.net/2019/08/22/jPSrYbs8qJAUtlW.png" alt></p><p><img src="https://i.loli.net/2020/02/16/OcCHqx9ki12f5Lj.png" alt="123456.png"></p><h3 id="Cookie-细节"><a href="#Cookie-细节" class="headerlink" title="Cookie 细节"></a>Cookie 细节</h3><p>Cookie 基于浏览器本地存储数据，因此，只有在保存了 Cookie 的那个浏览器上能够使用该 Cookie。<strong>同一设备不同浏览器之间，Cookie 不通用。</strong></p><p>Cookie 的存储大小有限制：4KB 左右，每次请求都要进行网络传输，占用带宽。一个浏览器最多允许 300 个 Cookie 一个网站最多储存 20 个 Cookie，由于 Cookie 是存在客户端上的，所以浏览器加入了一些限制确保 Cookie 不会被恶意使用。</p><p>Cookie 的同源策略：Cookie 同样也有同源策略，不过与 AJAX 略微不用。AJAX 需要完全同源，而 Cookie 只需要同一父级域名即可。 比如： 请求 qq.com 下的资源时，会带上 qq.com 对应的 Cookie，不会带上 baidu.com 的 Cookie； 请求 v.qq.com 下的资源时，浏览器不仅会带上 v.qq.com 的 Cookie，还会带上 qq.com 的 Cookie 。在这里，qq.com 就是 v.qq.com 的父级域名</p><p>Cookie主要用于以下三个方面：</p><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><p>Cookie 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。由于服务器指定 Cookie 后，浏览器的每次请求都会携带 Cookie 数据，会带来额外的性能开销（尤其是在移动环境下）。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API" target="_blank" rel="noopener">Web storage API</a> （本地存储和会话存储）或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a> 。</p><p>因为 Cookie 存储在客户端而客户端，即可见即不安全的原则，Cookie 容易被别有用心的人利用对自己的站点发起攻击，如：XSS，CSRF，都是利用的 Cookie 发起的攻击。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><blockquote><p>Session 是服务器端使用的一种记录客户端状态的机制，使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。不同于 Cookie 的是， Session 是保存在服务器端的。其实 Session 的实现最终还是 Cookie 。当我们用 Session 时，服务器端返回却是一段 Cookie 。从而可以说 Session 的实现依赖 Cookie。</p></blockquote><p>客户端访问服务器端，如果会使用到 Session，那么服务器端在 HTTP 响应报头当中会插入 Set-Cookie ,而这段 Cookie 记录着什么呢？记录着 SeesionID 。</p><p><img src="https://i.loli.net/2019/08/22/VDNZKPlfM5mu7bw.png" alt></p><p>客户端再次请求服务器端的时候，在 HTTP 请求报头当中自动插入 Cookie(Cookie 的值也就是 SeesionID)，服务器端拿到 Cookie 之后，读取当中的 SeesionID，会自动去寻找到这个 Session 文件所存放的位置（ PHP 当中 Session 属于持久存储在磁盘当中，默认 24 分钟之后删除数据，删除的是数据而不是删除这个 Session 文件）读取数据。在 PHP 当中默认的就是浏览器关闭， SessionID 销毁。</p><p><img src="https://i.loli.net/2019/08/22/dVJRSygoAp6ksu2.png" alt></p><p><img src="https://i.loli.net/2020/02/16/NvZuei68fsP9IBh.png" alt="是打算打算的.png"></p><p>以下是 PHP Seesion 的配置</p><pre><code>session.save_path = &quot;/home/jialaolian/Desktop/Session&quot;#这个就是你session存放的地址session.use_cookies=1#把这个的值设置为1，利用cookie来传递sessionidsession.cookie_lifetime=0#这个代表SessionID在客户端Cookie储存的时间，默认是0，代表浏览器一关闭SessionID就销毁session.gc_maxlifetime=1440#这个是Session数据在服务器端储存的时间，如果超过这个时间，那么Session数据就自动删除！</code></pre><h3 id="Session-细节"><a href="#Session-细节" class="headerlink" title="Session 细节"></a>Session 细节</h3><p>面试题当中经常会出现禁用了 Cookie 之后 Session 还可以用嘛？</p><p>答案：可以！</p><p>session 实现关键是 sessionID，只需要将 sessionID 传递给浏览器，浏览器在请求的时候再将 sessionID 传递给服务器，就可以实现 session。所以，可以使用在 URL 中插入查询参数的方式来实现 sessionID 的传递。</p><p>假如你使用了 Nginx 服务器软件做了负载均衡，那么你会发现丢失 Session 的问题。出现丢失 Session 问题呢，我们可以使用用 Nginx ip_hash 算法解决。</p><h3 id="Session-和-Cookie-的区别"><a href="#Session-和-Cookie-的区别" class="headerlink" title="Session 和 Cookie 的区别"></a>Session 和 Cookie 的区别</h3><ul><li>session 在服务器端，cookie 在客户端。</li><li>session 用户无法查看和修改，cookie 用户可以查看修改。</li><li>session 和 cookie 的存储容量不同。</li><li>session 的实现依赖于 sessionID，而 sessionID 又存储在 cookie 上，所以，可以这么说：session 是基于 cookie 实现的一种数据存储方式。</li><li>他们共同点，因为 Session 需要依赖 Cookie 所以 XSS 与 CSRF 对他们都有效。 </li><li>Cookie 只能存储字符串，而且 Session 不限制。</li></ul><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><blockquote><p>Token 我们的中文翻译‘令牌’</p></blockquote><h6 id="Token-的引入："><a href="#Token-的引入：" class="headerlink" title="Token 的引入："></a>Token 的引入：</h6><p>Token 是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token 便应运而生。</p><h6 id="Token-的定义："><a href="#Token-的定义：" class="headerlink" title="Token 的定义："></a>Token 的定义：</h6><p>Token 是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个 Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。</p><h6 id="使用-Token-的目的："><a href="#使用-Token-的目的：" class="headerlink" title="使用 Token 的目的："></a>使用 Token 的目的：</h6><p>Token 的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。</p><h6 id="Token-的优点："><a href="#Token-的优点：" class="headerlink" title="Token 的优点："></a>Token 的优点：</h6><p>扩展性更强，也更安全点，非常适合用在 Web 应用或者移动应用上。Token 的中文有人翻译成 “令牌”，我觉得挺好，意思就是，你拿着这个令牌，才能过一些关卡。</p><h6 id="Token-一般用在三个地方"><a href="#Token-一般用在三个地方" class="headerlink" title="Token 一般用在三个地方:"></a>Token 一般用在三个地方:</h6><p>①防止表单重复提交<br>②anti csrf 攻击（跨站点请求伪造）<br>③身份验证（单点登录）</p><p>Token 类似与 HTTP 协议当中的<strong>无状态</strong>特性，他不需要在服务器端保留用户的认证信息或者会话信息。这就意味着基于 Token 认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><p>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器</li><li>服务器进行验证用户的信息</li><li>服务器通过验证发送给用户一个 token</li><li>客户端存储 token，并在每次请求时附送上这个 token 值</li><li>服务端验证 token 值，并返回数据</li></ul><blockquote><p>原文地址：</p><p><a href="https://blog.csdn.net/cmj6706/article/details/79032703" target="_blank" rel="noopener">https://blog.csdn.net/cmj6706/article/details/79032703</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 会话技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 会话技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议简单理解</title>
      <link href="/2019/08/11/HTTP%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/"/>
      <url>/2019/08/11/HTTP%E5%8D%8F%E8%AE%AE%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简述历史"><a href="#简述历史" class="headerlink" title="简述历史"></a>简述历史</h2><blockquote><p>HTTP 协议(超文本传输协议 HyperText Transfer Protocol )，它是基于 TCP/IP 协议的应用层传输协议，简单来说就是客户端和服务端进行数据传输的一种规则。默认使用 80 端口。</p><p>HTTP 协议工作于客户端-服务端架构之上。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。 WEB 服务器根据接收到的请求后，向客户端发送响应信息。</p><blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g654ktgyvbj20fb051dfr.jpg" alt></p></blockquote><p>1991年发布的 HTTP/0.9 版本发布，该版本及其的简单，只有一个命令 GET 。</p><p>1996年5月份， HTTP/1.0 版本发布，内容大大的增加。首先可以发送任何格式的内容，除了传输文字，还可以传送图片、视频、二进制文件。其次除了GET 命令，还引入了 POST 和 HEAD 命令也就是我们说的简单请求方式。1.0 版本缺点无法做到持久连接，造成大量的通信开销。</p><p>1997年1月，HTTP/1.1 版本发布，他进一步的完善了 HTTP 协议，目前来说我们用的最多的还是 HTTP/1.1 版本。1.1 版本最大的变化就是引入了持久连接，只要 TCP 链接默认不关闭，那么他就可以一直复用。不用声明 Connection: keep-alive，目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。</p><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3 。3 版本的最大的改变，可能会抛弃掉 TCP 协议使用 UDP 协议。</p></blockquote><h2 id="TCP-协议简述"><a href="#TCP-协议简述" class="headerlink" title="TCP 协议简述"></a>TCP 协议简述</h2><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g5w31tlidzj20o10hbgpo.gif" alt></p><blockquote><p>建立 TCP 需要三次捂手建立连接，与四次挥手断开连接。整个过程如下图：</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g658ctyl3jj20f60lct9v.jpg" alt></p><h3 id="TCP-三次捂手"><a href="#TCP-三次捂手" class="headerlink" title="TCP 三次捂手"></a>TCP 三次捂手</h3><p>首先客户端发送连接请求报文，服务端接收连接后回复 ACK 报文，并为这次连接分配资源。客户端接收到 ACK 报文后也向服务端发送 ACK 报文，并分配资源，这样 TCP 连接就建立了。其实所谓的三次捂手其实就是建立一个 TCP 连接时，需要客户端和服务端总共发送三个包，三次捂手的目的是个连接服务器指定的端口，建立 TCP 连接，并同步连接双方的序列号和确认并交换 TCP 窗口大小信息，在 SOCKET 编程当中，客户端执行 connect() 时，将会触发三次捂手：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g658o2qh0ij20f109374f.jpg" alt></p><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><p>TCP 连接的拆除需要发送四个包，客户端或者服务器端均可主动发起挥手动作，在 SOCKET 编程中，任何一方执行 close() 即可产生挥手操作。假设客户端发起中断连接请求，就先发送 FIN 报文。服务端接到 FIN 报文后，但是如果还有数据没有发送完成，则不必急着关闭 Socket ，可以继续发送数据。所以服务器端先发送 ACK ，告诉客户端：请求已经收到了，但是我还没准备好，请继续等待停止的消息。这个时候客户端就进入 FIN_WAIT 状态，继续等待服务端的 FIN 报文。当服务端确定数据已发送完成，则向客户端发送 FIN 报文，告诉客户端：服务器这边数据发完了，准备好关闭连接了。客户端收到 FIN 报文后，就知道可以关闭连接了，但是他还是不相信网络，所以发送 ACK 后进入 TIME_WAIT 状态， 服务端收到 ACK 后，就知道可以断开连接了。客户端等待了 2MSL 后依然没有收到回复，则证明服务端已正常关闭，最后，客户端也可以关闭连接了至此， TCP 连接就已经完全关闭了！关闭连接的过程如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g658xy3fgrj20by085dfx.jpg" alt></p><h2 id="HTTP-工作流程"><a href="#HTTP-工作流程" class="headerlink" title="HTTP 工作流程"></a>HTTP 工作流程</h2><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w3bsgdqmj20fy06o75n.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w3f1g673j20kh09cdiv.jpg" alt></p><h2 id="HTTP-协议的特点"><a href="#HTTP-协议的特点" class="headerlink" title="HTTP 协议的特点"></a>HTTP 协议的特点</h2><ul><li>支持客户/服务器模式：请求 响应</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。每种 方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。早期这么做的原因是请求资源少，追求快。后来通过 Connection: Keep-Alive 实现长连接</li><li>无状态：HTTP 协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ul><p>HTTP 是一种无状态协议，HTTP 协议本身不会对发送过来的请求和响应的通信状态做一个持久化处理。这样做的目的就是为了保证 HTTP 协议的简单性，从而能够快速的处理大量的事务，提高效率。</p><p>然而在很多的场景当中，无状态的特性就让我们非常尴尬，比如说我们需要保持一个用户登录状态，由于我们 HTTP 协议无状态的特点，无法向服务器证明我们’认识’，所以我们需要引入别的技术来做处理。比如：cookie</p><h2 id="HTTP-URL"><a href="#HTTP-URL" class="headerlink" title="HTTP URL"></a>HTTP URL</h2><pre class="line-numbers language-php"><code class="language-php">http<span class="token punctuation">:</span><span class="token comment" spellcheck="true">//host[":"port][abs_path]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>host: 代表主机域名或IP地址</li><li>port: 端口号，缺省端口80</li><li>abs_path : 请求资源的URL，如果没有，填 “/“，通常浏览器会帮我们自动完成。<br>EG:</li><li>举个栗子：<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> </li></ul><h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><p>下图是在网上找的一张图，觉得能很好的表达HTTP请求的所发送的数据格式。</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w3ngr7gfj20kr06lmx0.jpg" alt></p><p>由上图可以看到，HTTP 请求由请求行，消息报头，请求正文三部分构成。</p><h3 id="HTTP-请求状态行"><a href="#HTTP-请求状态行" class="headerlink" title="HTTP 请求状态行"></a>HTTP 请求状态行</h3><p>请求行由请求 Method ,  URL 字段和 HTTP Version 三部分构成, 总的来说请求行就是定义了本次请求的请求方式, 请求的地址, 以及所遵循的 HTTP 协议版本例如：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token constant">GET</span> <span class="token operator">/</span>example<span class="token punctuation">.</span>html <span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token function">1</span> <span class="token punctuation">(</span><span class="token constant">CRLF</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>HTTP 协议的方法有：</p><ul><li>GET： 请求*<em>获取 *</em>Request-URI 所标识的资源</li><li>POST： 在 Request-URI 所标识的资源后<strong>增加</strong>新的数据</li><li>HEAD： 请求获取由 Request-URI 所标识的资源的<strong>响应消息报头</strong></li><li>PUT： 请求服务器<strong>存储或修改</strong>一个资源，并用 Request-URI 作为其标识</li><li>DELETE： 请求服务器*<em>删除 *</em>Request-URI 所标识的资源</li><li>TRACE： 请求服务器回送收到的请求信息，主要用于<strong>测试或诊断</strong></li><li>CONNECT： 保留将来使用</li><li>OPTIONS： 请求查询服务器的性能，或者查询与资源相关的选项和需求</li></ul><h3 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a>HTTP 请求头</h3><p>消息报头由一系列的键值对组成，允许客户端向服务器端发送一些附加信息或者客户端自身的信息，主要包括：</p><table><thead><tr><th>Header</th><th>解释</th><th>示例</th></tr></thead><tbody><tr><td>Accept</td><td>告诉服务器，客户端支持的数据类型。</td><td>Accept: text/plain, text/html</td></tr><tr><td>Accept-Charset</td><td>告诉服务器，客户端采用的编码。</td><td>Accept-Charset: iso-8859-5,utf-8</td></tr><tr><td>Accept-Encoding</td><td>告诉服务器，客户机支持的数据压缩格式。</td><td>Accept-Encoding: compress, gzip</td></tr><tr><td>Accept-Language</td><td>告诉服务器，客户机的语言环境。</td><td>Accept-Language: en,zh</td></tr><tr><td>Accept-Ranges</td><td>可以请求网页实体的一个或者多个子范围字段</td><td>Accept-Ranges: bytes</td></tr><tr><td>Authorization</td><td>HTTP授权的授权证书类型</td><td>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Cache-Control</td><td>指定请求和响应遵循的缓存机制</td><td>Cache-Control: no-cache</td></tr><tr><td>Connection</td><td>表示是否需要持久连接（HTTP 1.1默认进行持久连接）</td><td>Keep-Alive</td></tr><tr><td>Cookie</td><td>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器</td><td>Cookie: $Version=1; Skin=new;</td></tr><tr><td>Content-Length</td><td>请求的内容长度</td><td>Content-Length: 348</td></tr><tr><td>Content-Type</td><td>请求的与实体对应的MIME信息</td><td>Content-Type: application/x-www-form-urlencoded</td></tr><tr><td>Date</td><td>请求发送的日期和时间</td><td>Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td>Expect</td><td>请求的特定的服务器行为</td><td>Expect: 100-continue</td></tr><tr><td>From</td><td>发出请求的用户的Email</td><td>From: <a href="mailto:xxx@163.com" target="_blank" rel="noopener">xxx@163.com</a></td></tr><tr><td>Host</td><td>指定请求的服务器的域名和端口号</td><td>Host: <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.zcmhi.com" target="_blank" rel="noopener">www.baidu.com</a></td></tr><tr><td>If-Match</td><td>只有请求内容与实体相匹配才有效</td><td>If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Modified-Since</td><td>客户机通过这个头告诉服务器，资源的缓存时间。</td><td>If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>If-None-Match</td><td>如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变</td><td>If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Range</td><td>如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag</td><td>If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td>If-Unmodified-Since</td><td>只在实体在指定时间之后未被修改才请求成功</td><td>If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT</td></tr><tr><td>Max-Forwards</td><td>限制信息通过代理和网关传送的时间</td><td>Max-Forwards: 10</td></tr><tr><td>Pragma</td><td>用来包含实现特定的指令</td><td>Pragma: no-cache</td></tr><tr><td>Proxy-Authorization</td><td>连接到代理的授权证书</td><td>Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td>Range</td><td>只请求实体的一部分，指定范围</td><td>Range: bytes=500-999</td></tr><tr><td>Referer</td><td>客户机通过这个头告诉服务器，它是从哪个资源来访问服务器的。（一般用于防盗链）</td><td>Referer: <a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.zcmhi.com%2Farchives%2F71.html" target="_blank" rel="noopener">www.zcmhi.com/archives/71…</a></td></tr><tr><td>TE</td><td>客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息</td><td>TE: trailers,deflate;q=0.5</td></tr><tr><td>Upgrade</td><td>向服务器指定某种传输协议以便服务器进行转换（如果支持）</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td>User-Agent</td><td>浏览器的具体信息</td><td>User-Agent: Mozilla/5.0 (Linux; X11)</td></tr><tr><td>Via</td><td>通知中间网关或代理服务器地址，通信协议</td><td>Via: 1.0 fred, 1.1 <a href="https://link.juejin.im/?target=http%3A%2F%2Fnowhere.com" target="_blank" rel="noopener">nowhere.com</a>(Apache/1.1)</td></tr><tr><td>Warning</td><td>关于消息实体的警告信息</td><td>Warn: 199 Miscellaneous warning</td></tr></tbody></table><h3 id="HTTP-请求正文"><a href="#HTTP-请求正文" class="headerlink" title="HTTP 请求正文"></a>HTTP 请求正文</h3><p>只有发送 POST 方式时才有请求正文，GET 方式没有请求正文</p><h3 id="HTTP-请求报文"><a href="#HTTP-请求报文" class="headerlink" title="HTTP 请求报文"></a>HTTP 请求报文</h3><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w4vnbdrvj20m80egaan.jpg" alt></p><h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><p>与 HTTP 请求类似，先上一张图：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w4wab05kj20kp06qt8k.jpg" alt></p><p>HTTP 响应也由三部分组成，包括状态行，消息报头，响应正文。</p><h3 id="HTTP-响应状态行"><a href="#HTTP-响应状态行" class="headerlink" title="HTTP 响应状态行"></a>HTTP 响应状态行</h3><p>状态行也由三部分组成，包括 HTTP 协议的版本，状态码，以及对状态码的文本描述。例如：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token constant">HTTP</span><span class="token operator">/</span><span class="token number">1.1</span> <span class="token number">200</span> <span class="token constant">OK</span> （<span class="token constant">CRLF</span>）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="HTTP-响应头"><a href="#HTTP-响应头" class="headerlink" title="HTTP 响应头"></a>HTTP 响应头</h3><table><thead><tr><th align="left">Header</th><th align="left">解释</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">Accept-Ranges</td><td align="left">表明服务器是否支持指定范围请求及哪种类型的分段请求</td><td align="left">Accept-Ranges: bytes</td></tr><tr><td align="left">Age</td><td align="left">从原始服务器到代理缓存形成的估算时间（以秒计，非负）</td><td align="left">Age: 12</td></tr><tr><td align="left">Allow</td><td align="left">对某网络资源的有效的请求行为，不允许则返回405</td><td align="left">Allow: GET, HEAD</td></tr><tr><td align="left">Cache-Control</td><td align="left">告诉所有的缓存机制是否可以缓存及哪种类型</td><td align="left">Cache-Control: no-cache</td></tr><tr><td align="left">Content-Encoding</td><td align="left">web服务器支持的返回内容压缩编码类型。</td><td align="left">Content-Encoding: gzip</td></tr><tr><td align="left">Content-Language</td><td align="left">响应体的语言</td><td align="left">Content-Language: en,zh</td></tr><tr><td align="left">Content-Length</td><td align="left">响应体的长度</td><td align="left">Content-Length: 348</td></tr><tr><td align="left">Content-Location</td><td align="left">请求资源可替代的备用的另一地址</td><td align="left">Content-Location: /index.htm</td></tr><tr><td align="left">Content-MD5</td><td align="left">返回资源的MD5校验值</td><td align="left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td align="left">Content-Range</td><td align="left">在整个返回体中本部分的字节位置</td><td align="left">Content-Range: bytes 21010-47021/47022</td></tr><tr><td align="left">Content-Type</td><td align="left">如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</td><td align="left">Content-Type: text/html; charset=utf-8</td></tr><tr><td align="left">Date</td><td align="left">原始服务器消息发出的时间</td><td align="left">Date: Tue, 15 Nov 2010 08:12:31 GMT</td></tr><tr><td align="left">ETag</td><td align="left">请求变量的实体标签的当前值</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td align="left">Expires</td><td align="left">响应过期的日期和时间</td><td align="left">Expires: Thu, 01 Dec 2010 16:00:00 GMT</td></tr><tr><td align="left">Last-Modified</td><td align="left">请求资源的最后修改时间</td><td align="left">Last-Modified: Tue, 15 Nov 2010 12:45:26 GMT</td></tr><tr><td align="left">Location</td><td align="left">用来重定向接收方到非请求URL的位置来完成请求或标识新的资源</td><td align="left">Location: <a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td align="left">Pragma</td><td align="left">包括实现特定的指令，它可应用到响应链上的任何接收方</td><td align="left">Pragma: no-cache</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">它指出认证方案和可应用到代理的该URL上的参数</td><td align="left">Proxy-Authenticate: Basic</td></tr><tr><td align="left">refresh</td><td align="left">应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）</td><td align="left">Refresh: 5; url=<a href="http://www.zcmhi.com/archives/94.html" target="_blank" rel="noopener">http://www.zcmhi.com/archives/94.html</a></td></tr><tr><td align="left">Retry-After</td><td align="left">如果实体暂时不可取，通知客户端在指定时间之后再次尝试</td><td align="left">Retry-After: 120</td></tr><tr><td align="left">Server</td><td align="left">web服务器软件名称</td><td align="left">Server: Apache/1.3.27 (Unix) (Red-Hat/Linux)</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置Http Cookie</td><td align="left">Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1</td></tr><tr><td align="left">Trailer</td><td align="left">指出头域在分块传输编码的尾部存在</td><td align="left">Trailer: Max-Forwards</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">文件传输编码</td><td align="left">Transfer-Encoding:chunked</td></tr><tr><td align="left">Vary</td><td align="left">告诉下游代理是使用缓存响应还是从原始服务器请求</td><td align="left">Vary: *</td></tr><tr><td align="left">Via</td><td align="left">告知代理客户端响应是通过哪里发送的</td><td align="left">Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)</td></tr><tr><td align="left">Warning</td><td align="left">警告实体可能存在的问题</td><td align="left">Warning: 199 Miscellaneous warning</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表明客户端请求实体应该使用的授权方案</td><td align="left">WWW-Authenticate: Basic</td></tr></tbody></table><h3 id="HTTP-响应状态码"><a href="#HTTP-响应状态码" class="headerlink" title="HTTP 响应状态码"></a>HTTP 响应状态码</h3><p>状态代码有三位数字组成，第一个数字定义了响应的<strong>类别</strong>，且有五种可能取值：</p><ul><li><p>1xx：<strong>指示信息</strong> - 表示请求已接收，继续处理</p></li><li><p>100 客户必须继续发出请求</p><ul><li>101 客户要求服务器根据请求转换 HTTP 协议版本</li></ul></li><li><p>2xx：<strong>成功</strong> - 表示请求已被成功接收、理解、接受</p></li><li><p>200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</p><ul><li>201 （已创建） 请求成功并且服务器创建了新的资源。</li><li>202 （已接受） 服务器已接受请求，但尚未处理。</li></ul></li><li><p>3xx：<strong>重定向</strong> - 要完成请求必须进行更进一步的操作</p></li><li><p>300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。</p></li><li><p>301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</p><ul><li>302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li></ul></li><li><p>4xx：<strong>客户端错误</strong> - 请求有语法错误或请求无法实现</p></li><li><p>400 （错误请求） 服务器不理解请求的语法。</p><ul><li>401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 （禁止） 服务器拒绝请求。</li></ul></li><li><p>5xx：<strong>服务器端错误</strong> - 服务器未能实现合法的请求</p></li><li><p>500 （服务器内部错误） 服务器遇到错误，无法完成请求。</p></li><li><p>501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。</p></li><li><p>502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。</p></li><li><p>503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。</p></li><li><p>504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。</p></li><li><p>505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</p></li></ul><h3 id="HTTP-响应报文"><a href="#HTTP-响应报文" class="headerlink" title="HTTP 响应报文"></a>HTTP 响应报文</h3><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w50fsridj20m80g7jrx.jpg" alt></p><h2 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h2><p>在实际的应用当中，客户端往往会发送一系列的请求，接着服务器端一一的响应。对于这些请求|响应，如果每次都经过一个单独的 TPC 连接发送，称为非持久链接。反之，如果每次都经过相同的 TCP 连接进行发送，称为持久链接</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5876x3xj20hi0cjglu.jpg" alt></p><p>非持久连接在每次的请求|响应之后就会断开连接，下次在重新建立新的 TCP 链接，这样就会造成大量的通信开销。例如前面提到的往返时间( RTT ) 就是在建立 TCP 连接的过程中的代价。</p><p>非持久连接给服务器带来了沉重的负担，每台服务器可能同时面对数以百计甚至更多的请求。持久连接就是为了解决这些问题，其特点是一直保持 TCP 连接状态，直到遇到明确的中断要求之后再中断连接。持久连接减少了通信开销，节省了通信量。</p><h2 id="GET-与-POST-请求之间的区别"><a href="#GET-与-POST-请求之间的区别" class="headerlink" title="GET 与 POST 请求之间的区别"></a>GET 与 POST 请求之间的区别</h2><table><thead><tr><th align="center">区别内容</th><th align="center">GET</th><th align="center">POST</th></tr></thead><tbody><tr><td align="center">点击返回/刷新按钮</td><td align="center">没有影响</td><td align="center">数据会重新发送（浏览器将会提示“数据被重新提交”）</td></tr><tr><td align="center">添加书签</td><td align="center">可以</td><td align="center">不可以</td></tr><tr><td align="center">缓存</td><td align="center">可以</td><td align="center">不可以</td></tr><tr><td align="center">编码类型（Encoding type）</td><td align="center">application/x-www-form-rulencoded</td><td align="center"><code>application/x-www-form-rulencoded</code> or <code>multipart/form-data</code> 请为二进制数据使用 <code>multipart</code> 编码</td></tr><tr><td align="center">历史记录</td><td align="center">有</td><td align="center">没有</td></tr><tr><td align="center">长度限制</td><td align="center">有</td><td align="center">没有</td></tr><tr><td align="center">数据类型限制</td><td align="center">只允许 ASCLll 字符类型</td><td align="center">没有限制，允许二进制数据</td></tr><tr><td align="center">安全性</td><td align="center">查询字符串会显示在地址栏的 URL 上，不安全，<strong>请不要使用 GET 请求提交敏感数据</strong></td><td align="center">因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，<strong>请使用数据加密</strong>。</td></tr><tr><td align="center">可见性</td><td align="center">查询字符串在地址栏的 URL 中可见</td><td align="center">查询字符串在地址栏的 URL 中不可见</td></tr></tbody></table><h2 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h2><h3 id="HTTP-的不足"><a href="#HTTP-的不足" class="headerlink" title="HTTP 的不足"></a>HTTP 的不足</h3><ul><li>通信使用明文(不加密),内容可能会被窃听</li><li>不验证通信方的身份,因此有可能遭遇伪装</li><li>无法证明报文的完整性,所以有可能已遭篡改</li></ul><h3 id="HTTPS-介绍"><a href="#HTTPS-介绍" class="headerlink" title="HTTPS 介绍"></a>HTTPS 介绍</h3><p>HTTP 协议中没有加密机制,但可以通 过和 SSL (Secure Socket Layer, <strong>安全套接层</strong> )或 TLS (Transport Layer Security, <strong>安全层传输协议</strong>)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。</p><pre class="line-numbers language-text"><code class="language-text">HTTP + 加密 + 认证 + 完整性保护 = HTTPS（HTTP Secure ）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5c2yjgaj20m80anwec.jpg" alt></p><p>HTTPS 采用<strong>共享密钥加密</strong>（对称）和<strong>公开密钥加密</strong>（非对称）两者并用的<strong>混合</strong>加密机制。若密钥能够实现安全交换,那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比,其处理速度要慢。</p><blockquote><p>所以应充分利用两者各自的优势, 将多种方法组合起来用于通信。 在<strong>交换密钥</strong>阶段使用<strong>公开密钥加密</strong>方式,之后的建立通信<strong>交换报文</strong>阶段 则使用<strong>共享密钥加密</strong>方式。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5dby1hrj20m80fz0tb.jpg" alt></p><p><code>HTTPS</code>握手过程的简单描述如下：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5w5dv56z8j20m80det9g.jpg" alt></p><ol><li><p>浏览器将自己支持的一套加密规则发送给网站。</p><pre><code>服务器获得浏览器公钥</code></pre></li><li><p>网站从中选出一组加密算法与 HASH 算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p><pre><code>浏览器获得服务器公钥</code></pre></li><li><p>获得网站证书之后浏览器要做以下工作：</p><p>(a). 验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。</p><p>(b). 如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码（接下来通信的密钥），并用证书中提供的公钥加密（共享密钥加密）。</p><p>(c) 使用约定好的 HASH 计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。</p><pre><code>  浏览器验证 -&gt; 随机密码  服务器的公钥加密 -&gt; 通信的密钥  通信的密钥 -&gt; 服务器</code></pre></li><li><p>网站接收浏览器发来的数据之后要做以下的操作：</p><p>(a). 使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致。</p><p>(b). 使用密码加密一段握手消息，发送给浏览器。</p><pre><code>  服务器用自己的私钥解出随机密码 -&gt; 用密码解密握手消息（共享密钥通信）-&gt; 验证HASH与浏览器是否一致（验证浏览器）</code></pre></li></ol><h3 id="HTTPS-的不足"><a href="#HTTPS-的不足" class="headerlink" title="HTTPS 的不足"></a>HTTPS 的不足</h3><ul><li>加密解密过程复杂，导致访问速度慢</li><li>加密需要认向证机构付费</li><li>整个页面的请求都要使用 HTTPS</li></ul><blockquote><p>参考地址：</p><p><a href="https://www.cnblogs.com/quan-coder/p/9277837.html" target="_blank" rel="noopener">https://www.cnblogs.com/quan-coder/p/9277837.html</a></p><p><a href="https://juejin.im/post/5ba65296f265da0ac8493503" target="_blank" rel="noopener">https://juejin.im/post/5ba65296f265da0ac8493503</a></p><p><a href="https://juejin.im/post/5d0de954e51d4556be5b3a6f" target="_blank" rel="noopener">https://juejin.im/post/5d0de954e51d4556be5b3a6f</a></p><p><a href="http://swiftlet.net/archives/1082" target="_blank" rel="noopener">http://swiftlet.net/archives/1082</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-处理跨域请求</title>
      <link href="/2019/08/07/Laravel%E4%B9%8B%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/"/>
      <url>/2019/08/07/Laravel%E4%B9%8B%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>出于安全性的原因，浏览器会限制 Script 中的跨域请求。由于 XMLHttpRequest 遵循同源策略，所有使用 XMLHttpRequest 构造 HTTP 请求的应用只能访问自己的域名，如果需要构造跨域的请求，那么开发者需要配合浏览器做出一些允许跨域的配置。</p><p>在前后端分离的应用中，需要使用 CORS 完成跨域访问。在 CORS中 发送<strong>非简单请求</strong>（简单请求也就是 GET、POST、HEAD，非简单请求：PUT、DELETE等）时，前端会发一个请求方式为 OPTIONS 的预请求，前端只有收到服务器对这个 OPTIONS 请求的正确响应，才会发送正常的请求，否则将抛出跨域相关的错误。</p><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>首先需要了解一下浏览器 <a href="https://baike.baidu.com/item/同源策略" target="_blank" rel="noopener">同源策略</a>，它是浏览器最核心也最基本的安全功能，同源的意思是，域名，协议，端口都相同。如果两个地址不同源，那么：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法相互读取；</li><li>DOM 无法相互获得；</li><li>AJAX 请求不能相互发送。</li></ol><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 是一个 W3C 标准，全称是 “跨域资源共享”（Cross-origin resource sharing），就是其中一种用来解决浏览器跨域的问题方法。这种方法的关键是在于服务器，只要服务器端返回了合适的头信息（Header），前端 JS 发送 AJAX 的时候就能访问跨域的资源，代码和同源时一致，无需做任何修改，用户也不会有感知。</p><ul><li>响应的头部应该追加 Access-Control-Allow-Orign，用来表明哪些请求源被允许访问资源内容</li><li>浏览器会对请求源和响应中的值进行匹配验证</li><li>对于跨域的请求，浏览器会预发送一个非简单方式的请求，来判断给定资源是否准备接受跨域资源访问</li><li>服务端应用通过检查请求头部的 Orign 来判定请求是否跨域。</li></ul><h3 id="使用-laravel-扩展包处理跨域请求"><a href="#使用-laravel-扩展包处理跨域请求" class="headerlink" title="使用 laravel 扩展包处理跨域请求"></a>使用 laravel 扩展包处理跨域请求</h3><blockquote><p>barryvdh/laravel-cors：<a href="https://packagist.org/packages/barryvdh/laravel-cors" target="_blank" rel="noopener">https://packagist.org/packages/barryvdh/laravel-cors</a>  </p><p>他是一个已经写好了的扩展包，唯一的功能就是帮我们解决跨域请求问题，使用也非常的简单</p></blockquote><h3 id="1、composer-安装扩展包"><a href="#1、composer-安装扩展包" class="headerlink" title="1、composer 安装扩展包"></a>1、composer 安装扩展包</h3><pre><code>$ composer require barryvdh/laravel-cors</code></pre><blockquote><p>Laravel 5.5 及以上版本支持自动包发现，无需注册服务提供者，Laravel 5.4 及以下版本需要手动在 config/app.php 中注册服务提供者</p></blockquote><h3 id="2、发布配置文件"><a href="#2、发布配置文件" class="headerlink" title="2、发布配置文件"></a>2、发布配置文件</h3><pre><code>$ php artisan vendor:publish --provider=&quot;Barryvdh\Cors\ServiceProvider&quot;</code></pre><blockquote><p>在我们的 config 目录下面会生成一个 cors.php 的配置文件</p></blockquote><h3 id="3、注册全局中间或路由中间"><a href="#3、注册全局中间或路由中间" class="headerlink" title="3、注册全局中间或路由中间"></a>3、注册全局中间或路由中间</h3><blockquote><p><em>app/Http/Kernel.php</em> </p><p> 下面注册全局中间件或者路由中间件</p></blockquote><pre><code>    protected $middleware = [        \Barryvdh\Cors\HandleCors::class, # cors 跨域处理全局中间件    ];</code></pre><pre><code>    protected $routeMiddleware = [        &#39;cors&#39; =&gt; \Barryvdh\Cors\HandleCors::class, # cors 跨域处理路由中间件    ];</code></pre><h3 id="4、自定义配置"><a href="#4、自定义配置" class="headerlink" title="4、自定义配置"></a>4、自定义配置</h3><p>可以看到只要使用了中间件，所有的请求都是可以通过的，也就是说，barryvdh/laravel-cors 的默认配置都是允许所有请求，当然我们可以修改这些配置：</p><p><em>config/cors.php</em></p><pre><code>    &#39;supportsCredentials&#39; =&gt; false,    &#39;allowedOrigins&#39; =&gt; [&#39;*&#39;],    &#39;allowedOriginsPatterns&#39; =&gt; [],    &#39;allowedHeaders&#39; =&gt; [&#39;*&#39;],    &#39;allowedMethods&#39; =&gt; [&#39;*&#39;],    &#39;exposedHeaders&#39; =&gt; [],    &#39;maxAge&#39; =&gt; 0,</code></pre><p>分别对应如下配置：</p><table><thead><tr><th>配置</th><th>对应的 Header</th><th>说明</th></tr></thead><tbody><tr><td>supportsCredentials</td><td>Access-Control-Allow-Credentials</td><td>是否携带 Cookie</td></tr><tr><td>allowedOrigins</td><td>Access-Control-Allow-Origin</td><td>允许的域名</td></tr><tr><td>allowedOriginsPatterns</td><td>Access-Control-Allow-Origin</td><td>通过正则匹配允许的域名</td></tr><tr><td>allowedHeaders</td><td>Access-Control-Allow-Headers</td><td>允许的 Header</td></tr><tr><td>allowedMethods</td><td>Access-Control-Allow-Methods</td><td>允许的 HTTP 方法</td></tr><tr><td>exposedHeaders</td><td>Access-Control-Expose-Headers</td><td>除了 6 个基本的头字段，额外允许的字段</td></tr><tr><td>maxAge</td><td>Access-Control-Max-Age</td><td>预检请求的有效期</td></tr></tbody></table><blockquote><p>原文地址：</p><p><a href="https://learnku.com/courses/laravel-package/solving-cross-domain-problems-cors-barryvdhlaravel-cors/2026" target="_blank" rel="noopener">https://learnku.com/courses/laravel-package/solving-cross-domain-problems-cors-barryvdhlaravel-cors/2026</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-扩展包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-安装redis与PHP安装redis扩展</title>
      <link href="/2019/08/05/Linux%E4%B9%8B%E5%AE%89%E8%A3%85redis%E4%B8%8EPHP%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/"/>
      <url>/2019/08/05/Linux%E4%B9%8B%E5%AE%89%E8%A3%85redis%E4%B8%8EPHP%E5%AE%89%E8%A3%85redis%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1、安装-gcc"><a href="#1、安装-gcc" class="headerlink" title="1、安装 gcc"></a>1、安装 gcc</h3><pre><code>sudo apt install gcc</code></pre><h3 id="2、下载并解压"><a href="#2、下载并解压" class="headerlink" title="2、下载并解压"></a>2、下载并解压</h3><pre><code>$ wget http://download.redis.io/releases/redis-5.0.5.tar.gz$ tar xzf redis-5.0.5.tar.gz$ cd redis-5.0.5$ make## 确定结束的时候没有报错：error 如果报错了别慌张复制错误代码谷歌百度，慢慢解决确认没问题后$ make install</code></pre><p>安装后的目录和文件看图说话：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5fvl2gqj21fo0u0jwr.jpg" alt></p><h3 id="创建配置目录复制配置文件"><a href="#创建配置目录复制配置文件" class="headerlink" title="创建配置目录复制配置文件"></a>创建配置目录复制配置文件</h3><pre><code>$ sudo mkdir /etc/redis</code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5jjenrwj21fo0u00vx.jpg" alt></p><h3 id="4、创建持久保持数据文件和创建启动服务"><a href="#4、创建持久保持数据文件和创建启动服务" class="headerlink" title="4、创建持久保持数据文件和创建启动服务"></a>4、创建持久保持数据文件和创建启动服务</h3><p>创建持久储存数据文件</p><pre><code>$ sudo mkdir /var/lib/redis</code></pre><p>先修改 redis.conf 配置文件</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5ms8tlsj20zb0camzc.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5myfpv3j20tb07nwfc.jpg" alt></p><p>新建 Redis 服务进程系统启动文件</p><pre><code>sudo gedit /etc/systemd/system/redis.service[Unit]Description=Redis In-Memory Data StoreAfter=network.target[Service]User=redisGroup=redisExecStart=/usr/local/bin/redis-server /etc/redis/redis.confExecStop=/usr/local/bin/redis-cli shutdownRestart=always[Install]WantedBy=multi-user.target</code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5qwbs3ej21fo0u0tkq.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5rba55bj21fo0u0wfs.jpg" alt></p><h3 id="PHP-安装-Redis-扩展"><a href="#PHP-安装-Redis-扩展" class="headerlink" title="PHP 安装 Redis 扩展"></a>PHP 安装 Redis 扩展</h3><pre><code>$ wget https://pecl.php.net/get/redis-5.0.2.tgz$ tar -zxf redis-5.0.2.tgz$ cd redis-5.0.2$ phpize</code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p5uztdurj21fo0u0n8g.jpg" alt></p><pre><code>$ ./configure --with-php-config=/usr/local/php/bin/php-config</code></pre><blockquote><p>记住了 -config 后面跟的是你自己 php-config 目录</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g5p5y4kyk5j21fo0u01dw.jpg" alt></p><pre><code>$ make &amp;&amp; make install</code></pre><blockquote><p>编译之后会在当前redis扩展这个目录下面生成一个 modeles 目录 里面会有个 redis.so</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g5p62aosh2j21fo0u0mym.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g5p62qcladj21fo0u041b.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p64jzujbj21fo0u0n0w.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5p65npmrxj21fo0u0doa.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-Artisan自定义命令</title>
      <link href="/2019/08/04/Laravel%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89Artisan%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/08/04/Laravel%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89Artisan%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>对于每一个开发人员来说，都有自己的一套习惯，而我就比较喜欢把一个项目分层开来。各司其职，自己是什么定位就做属于自己定位的事情。当然一个一个文件创建，那么太费事情也不太方便。Laravel 为我们提供了自定义 Artisan 命令的方案， 给我提供了很大的便捷以自定义的灵活！</p><h3 id="Artisan-自定义命令创建-services-服务层"><a href="#Artisan-自定义命令创建-services-服务层" class="headerlink" title="Artisan 自定义命令创建 services 服务层"></a>Artisan 自定义命令创建 services 服务层</h3><h3 id="1、新建命令"><a href="#1、新建命令" class="headerlink" title="1、新建命令"></a>1、新建命令</h3><pre><code>php artisan make:command AddService</code></pre><p>执行该命令，将会在 <code>app\Console</code> 目录下生成 Commands 目录，同时在 <code>app\Console\Commands</code> 目录下生成 AddService.php 文件</p><h3 id="2、创建存根目录及模板文件"><a href="#2、创建存根目录及模板文件" class="headerlink" title="2、创建存根目录及模板文件"></a>2、创建存根目录及模板文件</h3><p>在 <code>app\Console\Commands</code> 目录下创建 Stubs 目录，然后在在 Stubs 目录下创建 services.stub </p><h3 id="3、编辑-services-stub"><a href="#3、编辑-services-stub" class="headerlink" title="3、编辑 services.stub"></a>3、编辑 services.stub</h3><pre><code>&lt;?php# 命名空间 自动获取等下添加的 Artisan 命令文件里面赋予的命名空间namespace DummyNamespace;[可以 use 命名空间]class DummyClass [可以编辑继承的父类]{    [可以定义各种方法，看自己需要]}</code></pre><h3 id="4、编辑-AddServices-php"><a href="#4、编辑-AddServices-php" class="headerlink" title="4、编辑 AddServices.php"></a>4、编辑 AddServices.php</h3><pre><code>&lt;?phpnamespace App\Console\Commands;use Illuminate\Console\GeneratorCommand;class AddServices extends GeneratorCommand{    /**     * 控制台命令名称     *     * @var string     */    protected $name = &#39;make:service&#39;;    /**     * 控制台命令描述     *     * @var string     */    protected $description = &#39;Create a new service  class&#39;;    /**     * 生成类的类型     *     * @var string     */    protected $type = &#39;Services&#39;;    /**     * 获取生成器的存根文件     *     * @return string     */    protected function getStub()    {        return __DIR__.&#39;/Stubs/services.stub&#39;;    }    /**     * 获取类的默认命名空间     *     * @param  string  $rootNamespace     * @return string     */    protected function getDefaultNamespace($rootNamespace)    {        # 这里是创建的命名空间，也是文件创建的目录地址，默认是 APP 下面        return $rootNamespace.&#39;\Http\Services&#39;;    }}</code></pre><h3 id="5、注册命令"><a href="#5、注册命令" class="headerlink" title="5、注册命令"></a>5、注册命令</h3><p>将以下内容添加到 Kernel.php 文件的 protected $commands = [] 属性数组中，使命令生效</p><pre><code>    protected $commands = [        //        \App\Console\Commands\AddServices::class    ];</code></pre><h3 id="6、测试命令"><a href="#6、测试命令" class="headerlink" title="6、测试命令"></a>6、测试命令</h3><pre><code>php artisan make:service TeachersService</code></pre><p><img src="https://i.loli.net/2019/09/09/MP8jLTvmNefycrt.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-Artisan自定义命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-快捷方式添加到应用程序</title>
      <link href="/2019/08/04/Linux%E4%B9%8B%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/08/04/Linux%E4%B9%8B%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我相信也有很多同僚是在用 Linux 的桌面系统工作，有时候我们装了一些软件但是他没有创建成应用只有快捷启动就让我们非常尴尬，极不方便的使用他们是非常难受的比如一些快速启动工具就无法使用，所有安装好一些软件后都非常建议的做成启动程序</p><pre><code>sudo gedit /usr/share/applications/navicat.desktop</code></pre><pre><code>[Desktop Entry]Type=ApplicationName=Apipost // 名称Comment=Apipost // 名称Icon=/home/jialaolian/Desktop/哪吒图片/1933435140-3.jpg // icon图片地址Exec=/usr/local/Apipost/ApiPost // 程序运行的地址Terminal=falseCategories=Application;</code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5ns2bl2qpj21hc0u0qdq.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eegy1g5ns4ir9ilj20nn0fh7em.jpg" alt></p><p>这样使用起来非常的方便咯</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-永久激活navicat实测有效</title>
      <link href="/2019/08/04/Linux%E4%B9%8B%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BBnavicat%E5%AE%9E%E6%B5%8B%E6%9C%89%E6%95%88/"/>
      <url>/2019/08/04/Linux%E4%B9%8B%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BBnavicat%E5%AE%9E%E6%B5%8B%E6%9C%89%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h3 id="1、下载解压"><a href="#1、下载解压" class="headerlink" title="1、下载解压"></a>1、下载解压</h3><p>第一步相信也就不多说了，也是下载解压好 navicat 之后不要启动他解压好安装好 win 之后关闭 navicat 即可</p><h3 id="2、下载最新的-release"><a href="#2、下载最新的-release" class="headerlink" title="2、下载最新的 release"></a>2、下载最新的 release</h3><blockquote><p>此为64位可执行文件 32请自行找资源</p></blockquote><pre><code>curl -O -L https://github.com/DoubleLabyrinth/navicat-keygen/releases/download/v3.1/navicat-keygen-for-x64.zip &amp;&amp; \unzip navicat-keygen-for-x64.zip</code></pre><h3 id="3、下载-navicat-pacther-sh-和-navicat-keygen-sh"><a href="#3、下载-navicat-pacther-sh-和-navicat-keygen-sh" class="headerlink" title="3、下载 navicat-pacther.sh 和 navicat-keygen.sh"></a>3、下载 navicat-pacther.sh 和 navicat-keygen.sh</h3><pre><code>curl -O -L https://raw.githubusercontent.com/DoubleLabyrinth/navicat-keygen/windows/bash/navicat-patcher.sh &amp;&amp; \chmod +x navicat-patcher.sh &amp;&amp; \curl -O -L https://raw.githubusercontent.com/DoubleLabyrinth/navicat-keygen/windows/bash/navicat-keygen.sh &amp;&amp; \chmod +x navicat-keygen.sh</code></pre><p>完成以上三步走，您的文件夹里面应该是和我一致的请看图</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5npgnyp6qj20ri0n575s.jpg" alt></p><h3 id="4、使用-navicat-patcher-exe-替换掉-navicat-exe-和-libcc-dll-里的-Navicat-激活公钥"><a href="#4、使用-navicat-patcher-exe-替换掉-navicat-exe-和-libcc-dll-里的-Navicat-激活公钥" class="headerlink" title="4、使用 navicat-patcher.exe 替换掉 navicat.exe 和 libcc.dll 里的 Navicat 激活公钥"></a>4、使用 navicat-patcher.exe 替换掉 navicat.exe 和 libcc.dll 里的 Navicat 激活公钥</h3><blockquote><p>注意了 这里千万别打开 navicat</p></blockquote><pre><code>./navicat-patcher.sh</code></pre><p><strong>Navicat Premium 12.1.12 简体中文版已通过测试</strong>。下面将是一份样例输出。</p><pre><code>****************************************************       Navicat Patcher by @DoubleLabyrinth       **           Release date: Jan 19 2019             ****************************************************Press Enter to continue or Ctrl + C to abort.MESSAGE: PatchSolution0 will be omitted.MESSAGE: PatchSolution3: Keywords[0] has been found:         Relative Machine Code Offset = +0x0000000001644a08         Relative Machine Code RVA    = +0x0000000001645608         Patch Offset                 = +0x00000000023d56e4         Patch Size                   = 3 byte(s).........MESSAGE: PatchSolution3: Keywords[110] has been found:         Relative Machine Code Offset = +0x000000000165155e         Relative Machine Code RVA    = +0x000000000165215e         Patch Offset                 = +0x0000000001651561         Patch Size                   = 1 byte(s)MESSAGE: PatchSolution2 will be omitted.MESSAGE: PatchSolution1: Keywords[0] has been found: offset = +0x021f7390.MESSAGE: PatchSolution1: Keywords[1] has been found: offset = +0x0074bd39.MESSAGE: PatchSolution1: Keywords[2] has been found: offset = +0x021f70a0.MESSAGE: PatchSolution1: Keywords[3] has been found: offset = +0x0074bd1f.MESSAGE: PatchSolution1: Keywords[4] has been found: offset = +0x021f708c.MESSAGE: Generating new RSA private key, it may take a long time.MESSAGE: New RSA private key has been saved to RegPrivateKey.pem.Your RSA public key:-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAsWnV5hQxlXvDA3Ad4k5NZLz4cO+iGEPegSovIDcwTo097I+0pXYKPTVl+0iKC5JtJRObb4Xx9yK9gGwqkcxoo6WzKq0xY1jz7X6obxwlQCNse3Os1wr0rIY0UzP1dCpkW/5MwGbFxiB6PEVqkzmJCmHBzZDRu/jAuL1nyoiGnUStqwENNYhyl4k7r8AiJkBZGMOCrj6v0JfgNna25Ce6QCFojlY4dkYQ5/7njQ3qpLwMeLEXEysMW3aUScSB68/vsHnB4C0fIkwfEPYZ/AC5AqbWHVbNmveB3rjV+tZZxXcLE8ArgKh1Gs+2VtnL09gwHm6WcpyPZ42G6tMDjWyw1wIDAQAB-----END PUBLIC KEY-----*******************************************            PatchSulution3              *******************************************@ +023d56e4: 4D 49 49 ---&gt; 4D 49 49@ +01644a63: 42 49 ---&gt; 42 49@ +01644a68: 6A ---&gt; 6A@ +01644ace: 41 ---&gt; 41.........@ +023d58d4: 36 63 6A ---&gt; 47 36 74@ +023d58d8: 78 6C 6A 75 75 51 61 ---&gt; 4D 44 6A 57 79 77 31@ +023d58e8: 77 49 44 41 ---&gt; 77 49 44 41@ +0165155c: 51 41 ---&gt; 51 41@ +01651561: 42 ---&gt; 42*******************************************            PatchSulution1              *******************************************@ +0x021f7390Previous:+0x00000000021F7390  44 37 35 31 32 35 42 37 30 37 36 37 42 39 34 31  D75125B70767B941+0x00000000021F73A0  34 35 42 34 37 43 31 43 42 33 43 30 37 35 35 45  45B47C1CB3C0755E+0x00000000021F73B0  37 43 43 42 38 38 32 35 43 35 44 43 45 30 43 35  7CCB8825C5DCE0C5.........@ +0x021f708cPrevious:+0x00000000021F7080  31 32 32 35 4f 45 29 2e 00 00 00 00 39 32 39 33  1225OE).....9293+0x00000000021F7090  33 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  3...............After:+0x00000000021F7080  31 32 32 35 4f 45 29 2e 00 00 00 00 32 37 45 38  1225OE).....27E8+0x00000000021F7090  45 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  E...............MESSAGE: Patch has been done successfully.</code></pre><h3 id="5、接下来使用-navicat-keygen-exe-来生成序列号和激活码"><a href="#5、接下来使用-navicat-keygen-exe-来生成序列号和激活码" class="headerlink" title="5、接下来使用 navicat-keygen.exe 来生成序列号和激活码"></a>5、接下来使用 navicat-keygen.exe 来生成序列号和激活码</h3><pre><code>./navicat-keygen.sh</code></pre><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5npkhlvr5j21fb0u0k3a.jpg" alt></p><blockquote><p>注意 此时到了  end： 这里是需要的请求码现目前你们还没有到这里就不要动了，千万别关闭终端！！！</p></blockquote><h3 id="6、打开-Navicat-配置一个代理"><a href="#6、打开-Navicat-配置一个代理" class="headerlink" title="6、打开 Navicat 配置一个代理"></a>6、打开 Navicat 配置一个代理</h3><p>再次注意到 input empty line to end: 这里时，千万别关闭终端，我们可以打开 navicat 了，如果 navicat 提示错误自动关闭，没关系多打开几次就好了！！！</p><p>打开 navicat 之后，在激活页面我们去配置一个代理。随便配置乱搞一通就好了，之后输入我们刚才得到的激活码</p><p>Serial number： 这个下面的就是生成出来的激活码，复制然后输入点激活，navicat 会提示激活失败叫你手动激活还是取消、选择 <strong>手动激活</strong>  因为我现在激活了，没办法截图很尴尬，在选择手动激活之后会看到一个请求码我们复制到 end 当中激活拿到激活码。注意复制到 end 里面之后，<strong>按二下空格键</strong>就会拿到我们的激活码了，然后复制到手动激活里面，点击激活即可完成永久激活咯！</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5npuag62vj21fb0u0kie.jpg" alt></p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5npux6x6wj217z0o8acb.jpg" alt></p><blockquote><p>原文地址：</p><p><a href="https://github.com/DoubleLabyrinth/navicat-keygen/blob/windows/README_FOR_LINUX.zh-CN.md" target="_blank" rel="noopener">https://github.com/DoubleLabyrinth/navicat-keygen/blob/windows/README_FOR_LINUX.zh-CN.md</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manjaro</title>
      <link href="/2019/08/04/Manjaro%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/08/04/Manjaro%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Manjaro-Linux"><a href="#Manjaro-Linux" class="headerlink" title="Manjaro Linux"></a>Manjaro Linux</h2><p>最强大最牛逼最好的 Linux 桌面发行版本，不接受任何的反驳！！！我是 KDE ，其他版本感觉上面都没有 KDE舒服！反正我感觉是最好用的版本！！！</p><p>Linux 桌面系统排行榜：<a href="https://distrowatch.com/" target="_blank" rel="noopener">https://distrowatch.com/</a></p><p><img src="https://i.loli.net/2020/03/22/YeAo9rb6CFSyVW5.png" alt="深度截图_选择区域_20200322025652.png"></p><p><img src="https://i.loli.net/2019/10/11/GiH5keFqWfunK8c.jpg" alt></p><p><img src="https://i.loli.net/2020/03/22/1Zt5pTfmuqFvMhD.png" alt="Screenshot_20200322_171912.png"></p><blockquote><p>为什么会选择 Manjaro 这个发行版本呢？</p><p>1、滚动升级</p><p>2、自动硬件检测安装</p><p>3、先进的包管理、最多软件支持的 Linux 发行版本</p><p>4、超级高度用户自定义、桌面、主题、界面、文件、操作、显示等等，全部可用户自定义</p><p>5、软件版本超级牛逼的同步快，基本与各个软件的版本持平</p><p>6、目前生态最好的一款 Linux 桌面版本之一（在我心里是第一）</p><p>7、本地化相比 18.10 之前已经做的非常好了，我又倒腾了目前 19.0.2 的 KDE 版本</p><p>8、超级稳定</p></blockquote><h3 id="中科大软件源"><a href="#中科大软件源" class="headerlink" title="中科大软件源"></a>中科大软件源</h3><pre><code>1.选择源sudo pacman-mirrors -i -c China -m rank 运行一段时间后，会出现选择框，这里选择http://mirrors.ustc.edu.cn/manjaro2.刷新缓存sudo pacman -Syy3.修改配置文件sudo vim /etc/pacman.conf添加到末尾[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch4.导入 GPG Keysudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring</code></pre><h3 id="最好包管理"><a href="#最好包管理" class="headerlink" title="最好包管理"></a>最好包管理</h3><pre><code># 个人比较喜欢 yaourtsudo pacman -S yaourt# yay 也是一种选择sudo pacman -S yay</code></pre><h3 id="最强-Shell"><a href="#最强-Shell" class="headerlink" title="最强 Shell"></a>最强 Shell</h3><pre><code># 最强 shell 当然个人观念sudo pacman -s fish# 设置默认，建议不要默认sudo chsh -s /usr/bin/fish</code></pre><h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><pre><code># 个人超爱sudo pacman -S kupfer# 另外推荐sudo pacman -S albert</code></pre><h3 id="最好输入法"><a href="#最好输入法" class="headerlink" title="最好输入法"></a>最好输入法</h3><pre><code># 安装企鹅输入法1、Fcitx2、Fcitx 配置3、kcm-fcitxsudo pacman -S Sunpinyin# 修改配置文件,之后注销sudo vim /etc/profileexport GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=@im=fcitx# 所有地方输入中文1、打开 Fcitx 配置2、全局配置-&gt;程序-&gt;在窗口间共享状态-&gt;选择所有</code></pre><h3 id="Cisco-AnyConnect"><a href="#Cisco-AnyConnect" class="headerlink" title="Cisco AnyConnect"></a>Cisco AnyConnect</h3><pre><code>### 如果安装了 Cisco 没有问题无需操作,如果有问题请按照下面重新操作# 1、注释用户验证sudo vim vpn_install.sh # Make sure we are root# if [ `id | sed -e &#39;s/(.*//&#39;` != &quot;uid=0&quot; ]; then#   echo &quot;Sorry, you need super user privileges to run this script.&quot;#   exit 1# fi# 2、创建 rc.dsudo mkdir /etc/rc.d# 3、安装,如果还有权限 root 允许./vpn_install.sh# 4、启动服务sudo /etc/rc.d/vpnagentd start# 错误解决方案https://bbs.archlinux.org/viewtopic.php?id=190444# 以上是下载安装 yaourt 安装完美支持，Manjaro 牛逼！yaourt -S cisco-anyconnect</code></pre><h3 id="谷歌浏览器"><a href="#谷歌浏览器" class="headerlink" title="谷歌浏览器"></a>谷歌浏览器</h3><pre><code>sudo pacman -S google-chrome</code></pre><h3 id="MySQL-可视化软件"><a href="#MySQL-可视化软件" class="headerlink" title="MySQL 可视化软件"></a>MySQL 可视化软件</h3><pre><code>yaourt -S valentina-studio</code></pre><h3 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h3><pre><code># 这个可以说真正原生(PS:基本跟 10 多年前一样，简洁)yaourt -s linuxqq# deepin 打包的 MIT yaourt -S deepin-wine-tim</code></pre><h3 id="网易云音乐"><a href="#网易云音乐" class="headerlink" title="网易云音乐"></a>网易云音乐</h3><pre><code># 安装网易云官方sudo pacman -S netease-cloud-music# 无法输入中文，请自行百度，19.0.2 暂时未解决# 这个第三方的也挺不错第三方yaourt -S iease-music</code></pre><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><pre><code># 如果安装 Hexo 使用了 我这么里就不说了，在我 扬帆启航 里面有一个链接里面有详细安装 Hexo 的教程在重新装完系统之后，前面部署过的 Hexo 可以继续的使用，只需要安装 Hexo 和删除 Hexo 下面的 .deploy_git/即可重新的 Push 到 github 上面！ # 安装 hexonpm install -g hexo-cli # 附上纤细安装 Hexo 文章https://godweiyang.com/2018/04/13/hexo-blog/https://github.com/blinkfox/hexo-theme-matery</code></pre><h3 id="深度"><a href="#深度" class="headerlink" title="深度"></a>深度</h3><pre><code># 深度终端，说实话 deepin 这个终端真心赞sudo pamcan -S deepin-terminal# 深度看图sudo pacman -S deepin-image-viewer# 深度截图sudo pacman -S deepin-screenshot</code></pre><h3 id="Teamviewer"><a href="#Teamviewer" class="headerlink" title="Teamviewer"></a>Teamviewer</h3><pre><code># 安装sudo pacman -S teamviewer# 启动服务systemctl start teamviewerd</code></pre><h3 id="百度网盘"><a href="#百度网盘" class="headerlink" title="百度网盘"></a>百度网盘</h3><pre><code># 百度官方 Linux 版本sudo pacman -S baidunetdisk-bin</code></pre><h3 id="更新系统后乱码"><a href="#更新系统后乱码" class="headerlink" title="更新系统后乱码"></a>更新系统后乱码</h3><pre><code># 18.10 之前更新系统之后出现乱码问题，缺少中文字体，但是比系统原来字体差许多sudo pacman -S wqy-microhei# 18.10 完成支持本地化！19.0.2 完美！！</code></pre><h3 id="Docky"><a href="#Docky" class="headerlink" title="Docky"></a>Docky</h3><pre><code># 想比较下他比 plank 吃内存一些，但是也不太影响，毕竟 plank 太过于简洁了！外貌协会不摆了！sudo pacman -S latte-dock</code></pre><h3 id="搜狗输入法"><a href="#搜狗输入法" class="headerlink" title="搜狗输入法"></a>搜狗输入法</h3><p>时隔差不多 2 年，搜狗更新了！</p><pre><code>1.打开 ”添加/删除软件“2.搜索Sogou3.安装fcitx-sogoupinyin4.安装fcitx-configtool5.安装fcitx-qt46.配置~/.xprofile    export GTK_IM_MODULE=fcitx    export QT_IM_MODULE=fcitx    export XMODIFIERS=@im=fcitx# 如果搜狗输入法不能输入中文检查一下是否有中文语言包，不建议安装搜狗输入法 太老了！而且 18 以后基本安装都有问题，不建议使用</code></pre><h3 id="微信，腾讯视频都出-Linux-版本，期待微信呀"><a href="#微信，腾讯视频都出-Linux-版本，期待微信呀" class="headerlink" title="微信，腾讯视频都出 Linux 版本，期待微信呀"></a>微信，腾讯视频都出 Linux 版本，期待微信呀</h3><pre><code># 这是 deepin yaourt -S deepin-wine-wechat# 网页打包版本yaourt -S electronic-wechat</code></pre><h3 id="Shutter"><a href="#Shutter" class="headerlink" title="Shutter"></a>Shutter</h3><p>Linux 下面最好的截图软件</p><pre><code>sudo pacman -S Shutter</code></pre><h3 id="Oss"><a href="#Oss" class="headerlink" title="Oss"></a>Oss</h3><pre><code># 1、下载 Osscurl https://oss-attachment.cn-hangzhou.oss.aliyun-inc.com/oss-browser/1.9.5/oss-browser-linux-x64.zip# 2、解压unzip oss-browser-linux-x64# 3、运行oss-browser</code></pre><h3 id="亿图思维导图"><a href="#亿图思维导图" class="headerlink" title="亿图思维导图"></a>亿图思维导图</h3><pre><code>yaourt -s mindmaster</code></pre><h3 id="微信开发工具"><a href="#微信开发工具" class="headerlink" title="微信开发工具"></a>微信开发工具</h3><pre><code>sudo pacman -S wechat-devtools</code></pre><h3 id="钉钉"><a href="#钉钉" class="headerlink" title="钉钉"></a>钉钉</h3><pre><code>yaourt -S dingtalk-electron</code></pre><h3 id="Phpstorm"><a href="#Phpstorm" class="headerlink" title="Phpstorm"></a>Phpstorm</h3><pre><code>yaourt -S phpstorm</code></pre><h3 id="Zeal"><a href="#Zeal" class="headerlink" title="Zeal"></a>Zeal</h3><pre><code># Linux 下面最好的离线文档，可以配合这 Phpstrom 使用pacman -S zeal# 安装好之后 Phpstrom 插件当中安装 dash 按住 ctrl+shift+d 即可调出文档</code></pre><h3 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a>Navicat</h3><pre><code>yaourt -S navicat# 附上破解 navicat 破解文章https://daixianjin.github.io/2019/08/04/Linux%E4%B9%8B%E6%B0%B8%E4%B9%85%E6%BF%80%E6%B4%BBnavicat%E5%AE%9E%E6%B5%8B%E6%9C%89%E6%95%88/</code></pre><h3 id="Redis-可视化工具"><a href="#Redis-可视化工具" class="headerlink" title="Redis 可视化工具"></a>Redis 可视化工具</h3><pre><code>yaourt -S redis-desktop-manageryaourt -S another-redis-desktop-manager</code></pre><h3 id="Vs-Code"><a href="#Vs-Code" class="headerlink" title="Vs Code"></a>Vs Code</h3><pre><code>pacman -S visual-studio-code-bin</code></pre><h3 id="DBeaver"><a href="#DBeaver" class="headerlink" title="DBeaver"></a>DBeaver</h3><pre><code>pacman -S dbeaver# 完美的 Linux 下面数据库可视化工具，换成19.0.2之后非常闪，很难受！</code></pre><h3 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h3><pre><code>yaourt -S typora</code></pre><h3 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h3><pre><code>yaourt -S postman</code></pre><h3 id="Goland"><a href="#Goland" class="headerlink" title="Goland"></a>Goland</h3><pre><code>sudo pacman -S goland</code></pre><h3 id="福昕"><a href="#福昕" class="headerlink" title="福昕"></a>福昕</h3><pre><code>sudo pacman -S foxitreader</code></pre><blockquote><p>好的推荐，请留言告知！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-生命周期</title>
      <link href="/2019/08/03/Laravel%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/08/03/Laravel%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在「日常生活」中 使用任何工具时，如果理解了该工具的工作原理。那么用起来就会更加得心应手。应用开发也是如此，当你能真正懂得一个功能背后实现原理时，用起来会更加顺手，方便。</p><p>文档存在目的是为了让你更加清晰地了解 Laravel 框架是如何工作。通过框架进行全面了解，让一切都不再感觉很「神奇」。相信我，这有助于你更加清楚自己在做什么，对自己想做的事情更加胸有成竹。就算你不明白所有的术语，也不用因此失去信心！只要多一点尝试、学着如何运用，随着你浏览文档的其他部分，你的知识一定会因此增长。</p><h3 id="PHP-的生命周期"><a href="#PHP-的生命周期" class="headerlink" title="PHP 的生命周期"></a>PHP 的生命周期</h3><p>PHP 的运行模式分二中：CLI 命令行模式，WEB 服务模式</p><h3 id="1、模块初始化阶段（MINIT）"><a href="#1、模块初始化阶段（MINIT）" class="headerlink" title="1、模块初始化阶段（MINIT）"></a>1、模块初始化阶段（MINIT）</h3><p>在这个阶段 PHP 首先检测 php.ini 文件种定义的扩展模块并对其进行初始化和加载的工作，如：pdo、mysqld、redis 等等我们需要的功能模块都要在这个阶段完成</p><h3 id="2、请求初始化阶段（RINIT）"><a href="#2、请求初始化阶段（RINIT）" class="headerlink" title="2、请求初始化阶段（RINIT）"></a>2、请求初始化阶段（RINIT）</h3><p>初始化本次脚本请求所需要的变量以及变量值内容符号表，我们熟知的$_SESSION,$_COOKIE,$GLOBAL,$_GET,$_POST 等等超全局变量都会在这个阶段完成初始化的工作 </p><h3 id="3、执行指定的-PHP-脚本程序"><a href="#3、执行指定的-PHP-脚本程序" class="headerlink" title="3、执行指定的 PHP 脚本程序"></a>3、执行指定的 PHP 脚本程序</h3><p>PHP 程序执行阶段所有的框架都是在这里开始</p><h3 id="4、请求处理完成阶段"><a href="#4、请求处理完成阶段" class="headerlink" title="4、请求处理完成阶段"></a>4、请求处理完成阶段</h3><p>这是第二个阶段的逆操作，在这个阶段，完成所有请求相关变量和符号表的清理工作，如 unset（$_POST）,然后按顺序调用扩展模块的 RSHUTDOWN 方法，通知扩展做好关闭前的准备工作。</p><h3 id="5、模块关闭阶段"><a href="#5、模块关闭阶段" class="headerlink" title="5、模块关闭阶段"></a>5、模块关闭阶段</h3><p>这是阶段（1）的逆操作， PHP 调用每个扩展的 MSHUTDOWN 方法释放内存  </p><h3 id="看图说话："><a href="#看图说话：" class="headerlink" title="看图说话："></a>看图说话：</h3><img src="http://ww1.sinaimg.cn/large/e73160eely1g5mqp7a9laj20wy0c1mxz.jpg"><blockquote><p>注意：上面的这个流程5个阶段一直都在执行，他是属于 CLI 模式下 PHP 的生命周期。随着服务器软件的崛起，我们现目前所用的模式都是 WEB 模式，且 WEB 模式下性能高于 CLI 模式，请问下面看</p><p>WEB 模式下，阶段 1 和阶段 5 只会执行一次，以后的每次请求会重复 2 到 4 的生命周期阶段，因此无需每次都重复的初始化扩展模块，进而节省了系统运行资源，带来了效率的提升。至此，咱们先给 Laravel 做一个合理的定位，<strong>Laravel 生命周期只运行在第三个阶段</strong>。其实不光 Laravel 框架，只要是使用 WEB 模式对请求进行处理的，其他的 PHP 开发框架的生命周期也是在第三个阶段</p></blockquote><h3 id="单一入口与多入口"><a href="#单一入口与多入口" class="headerlink" title="单一入口与多入口"></a>单一入口与多入口</h3><p>Laravel 所有的请求入口都是 public/index.php，这是一个典型的单一入口，说到单一入口那就也得说说他的优势与劣势。既然要说单一入口，那么肯定也得了解一下多入口咯。</p><h3 id="多入口"><a href="#多入口" class="headerlink" title="多入口"></a>多入口</h3><p>通过访问不同的文件，完成用户的操作，我们最开始学习 PHP 时就是多入口。</p><pre><code>login.php 访问的登录页面index.php 访问的是首页game.php  访问的是游戏页面    </code></pre><h3 id="单一入口"><a href="#单一入口" class="headerlink" title="单一入口"></a>单一入口</h3><p>单一入口就是用一个文件处理所有 HTTP 的请求，这个文件一般来说我们都是 index.php 定义单一入口的访问的文件，所有的请求都得走 index.php</p><p>优势：单一入口相当于有一个守卫，对于安全检测非常好，也容易控制权限</p><p>劣势：由于所有 HTTP 请求都是针对 index.php 这样 URL 看起来不美观，而且对搜索引擎不太友好</p><p>但是没有关系，我们可以通过重写 URL 和采用 PATHINFO 访问，亦可解决劣势上的问题</p><pre><code>public  --- index.php</code></pre><p>看图理解</p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5mgz9b4c1j217m0e37ba.jpg"><h3 id="Laravel-的生命周期"><a href="#Laravel-的生命周期" class="headerlink" title="Laravel 的生命周期"></a>Laravel 的生命周期</h3><p>OK，现在我们跟随一个 “请求” 进入到 Laravel 内部，看看在 Laravel 框架内部，它将经历什么样的磨难，能否取得“大乘佛法三藏真经”。这个请求首先会进入 <strong>public\index.php</strong> 入口文件，所有的网络请求都会从这里进入，就像大家学习编程语言时接触的 <strong>main()</strong>  函数一样。 </p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5nkvqhgnxj20xg0ec3yt.jpg" alt></p><pre><code> 1.使用 Composer 的自动加载功能，把所有需要使用的 PHP 文件添加到系统中以备调用  require __DIR__.&#39;/../vendor/autoload.php&#39;;  2.创建 Laravel 单例应用实例  $app = require_once __DIR__.&#39;/../bootstrap/app.php&#39;; 3.最关键的步骤，接受请求，对请求进行处理，返回请求处理的结果  $kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);  $response = $kernel-&gt;handle(      $request = Illuminate\Http\Request::capture()  );  $response-&gt;send(); 4.请求结束，进行回调  $kernel-&gt;terminate($request, $response);</code></pre><p>人呐，就是很奇怪，我们都知道 Laravel 源代码蕴含的巨大价值，但是很多使用<br>Laravel 或者 PHP 作为吃饭工具的码农们以及学习者，很少有人真正的去研究一下 Laravel 源码，说到原因呢，无非就是 “懒” 和<br>“恐惧”，看似“懒”是主要原因，仔细想想的话，似乎不是那么回事儿， “恐惧” 才是，人如果无法克服自己的心里障碍，就很难行动起来，而 “懒”<br>通常只会导致拖延而已，一件事情如果你拖了太久，就不再只是简单的 “懒” 的问题了。“舒适区”<br>很舒服，但是舒适区面积会随着时间加速缩小，我们又能舒服多久。好了，不废话了，咱们开始看看代码吧，真的没多少，也没必要了解得太具体，太八股了也不好。</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5nl0e44vnj21000hjmy4.jpg" alt></p><p>用户的网络请求就是传递给 Laravel 应用创建的 <strong>HTTP 内核</strong> 进行网络请求处理，并把处理后的网络响应结果返回给用户的。网络请求就是在第三步被 <strong>HTTP $Kernal</strong> 对象的 handle 函数接收并完成处理的，handle函数接收的参数就是用户传递过来的网络请求 。由于上述 $kernel-&gt;handle() 是如此的重要，我们真的需要先跟它打打招呼交个朋友才行，那咱们就先走个回头路，看一看<br>网络请求 传递给 Laravel HTTP Kernel 之前，Laravel<br>都做了什么，虽然这部分内容不是网络请求生命周期走的流程，但是却是 Laravel 生命诞生的地方，咱们这次的专题是 Laravel<br>的生命周期，所以这部分内容还是要提一提的，到了这里很多朋友应该可以开始解开疑惑了，是的，我们这个专题其实涉及到了两个生命周期，一个是 <strong>网络请求的生命周期</strong>，一个就是 <strong>Laravel 生命周期</strong>。由于这两口子水乳交融，夫唱妇随，大部分时间他们都抱在一块儿羞羞，导致很多人把它当作一个东西了，而这也是为什么很多人会觉得网上的教程有些地方总觉得不对劲的原因。从上图中，咱们已经可以看出来，网络响应（Response）已经在第三步就已经返回给用户了。网络响应<br>返回后，Laravel 的生命周期并未结束，它还有一些善后工作需要处理，也就是第四步 <strong>“请求结束，进行回调”</strong> ，执行完了这一步之后，Laravel 才算是到了一个终结点。再贴一次代码吧，不少技术人员看不见代码就难受：</p><pre><code> 3. 最关键的步骤，接受请求，对请求进行处理，返回请求处理的结果    $kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);  $response = $kernel-&gt;handle(      $request = Illuminate\Http\Request::capture()  );  $response-&gt;send(); 4. 请求结束，进行回调  $kernel-&gt;terminate($request, $response);</code></pre><p>本来写这篇文章是想着要不就不区分它们了吧，像网上其他教程那样当成一个东西写就行了，但是按照这种逻辑会让人产生混乱，不利用大家真正理解<br>Laravel 或者说其他网络开发框架，所以还是做了一个区分，先把网络请求的生命周期交代清楚了，咱们再去详细分析 Laravel<br>的生命周期，思路上就会更清晰明了些，有些东西八股一下还是有必要的。接下来，咱们就可以暂时把网络请求放一边，看一看 Laravel 的创建过程：</p><p><strong>1.  加载 Composer 生成的 autoload.php 自动加载文件</strong></p><p>就是加载初始化第三方依赖</p><p><strong>2.  创建 Laravel 应用容器对象 $app ( Service Container )</strong> </p><pre><code> $app = new Illuminate\Foundation\Application( dirname(__DIR__) );  $app-&gt;singleton(      Illuminate\Contracts\Http\Kernel::class,      App\Http\Kernel::class  );  $app-&gt;singleton(      Illuminate\Contracts\Console\Kernel::class,      App\Console\Kernel::class  );  $app-&gt;singleton(      Illuminate\Contracts\Debug\ExceptionHandler::class,      App\Exceptions\Handler::class  );  return $app;</code></pre><p>在这里基本也没啥难以理解的东西，创建了 $app 容器对象，绑定了 HTTP<br>Kernal 和 Console Kernel，分别用来处理 HTTP 网络请求和 CLI 请求（ 执行 php artisan<br>相关命令请求），还绑定了用来处理应用运行异常的调试处理器</p><pre><code># Laravel $app 创建时的构建函数  public function __construct($basePath = null)  {      if ($basePath) {          $this-&gt;setBasePath($basePath);      }      $this-&gt;registerBaseBindings();      $this-&gt;registerBaseServiceProviders();      $this-&gt;registerCoreContainerAliases();  }</code></pre><p>上面是 <strong>$app</strong> 实例创建的具体逻辑，我们看到也没啥难以理解的内容，无非就是设定路径，注册基础绑定信息，注册基础<br>Service Provider 和<br>Aliases，而做这些工作的意义就是可以帮助我们更方便的访问和获取项目目录中的文件信息，加载配置文件，加载自定义的类，加载Service，aliases<br>定义了如何把开发框架中最基础的服务注册到 <strong>Service Container</strong> 中，看了这部分代码，咱们就知道为啥 <strong>app(‘files’)</strong> 和 <strong>app (‘Illuminate\Filesystem\Filesystem’)</strong> 这两种使用方法都可以拿到 FileSystem 服务的原因了</p><pre><code> public function registerCoreContainerAliases()  {      foreach ([          &#39;app&#39;                  =&gt; [\Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class,  \Psr\Container\ContainerInterface::class],          &#39;auth&#39;                 =&gt; [\Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class],          &#39;auth.driver&#39;          =&gt; [\Illuminate\Contracts\Auth\Guard::class],          &#39;blade.compiler&#39;       =&gt; [\Illuminate\View\Compilers\BladeCompiler::class],          &#39;cache&#39;                =&gt; [\Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class],          &#39;files&#39;                =&gt; [\Illuminate\Filesystem\Filesystem::class],          &#39;filesystem&#39;           =&gt; [\Illuminate\Filesystem\FilesystemManager::class, \Illuminate\Contracts\Filesystem\Factory::class],                                                                                                          .                                                                                   &#39;view&#39;                 =&gt; [\Illuminate\View\Factory::class, \Illuminate\Contracts\View\Factory::class],      ] as $key =&gt; $aliases) {          foreach ($aliases as $alias) {              $this-&gt;alias($key, $alias);          }      }  }</code></pre><p>其实很多人之所以不愿意去看代码，有一个主要的原因就是没有理解<br>Service，Service Container，Service Provider，Facades，Contracts<br>这些核心概念以及他们之间的关联，如果你对 Laravel 核心概念不清楚，我也真的不建议你看源码，你会想把电脑砸掉的 ～</p><p><strong>3.  创建 Laravel HTTP Kernel 核心，接收用户的网络请求，处理并返回响应结果</strong></p><p>咱们终于又回来了，咱们先来看看创建 Kernel 的时候都做了啥，HTTP 内核继承自 Illuminate\Foundation\Http\Kernel 类，这个类中拥有三个核心成员变量</p><pre><code>  protected $app;  protected $router;  protected $bootstrappers = [      \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class,     # 加载 .env 中的配置信息      \Illuminate\Foundation\Bootstrap\LoadConfiguration::class,                # 加载 config 目录中所有配置文件的配置信息      \Illuminate\Foundation\Bootstrap\HandleExceptions::class,                 # 异常处理      \Illuminate\Foundation\Bootstrap\RegisterFacades::class,                # 注册门面      \Illuminate\Foundation\Bootstrap\RegisterProviders::class,               # 注册Service Providers      \Illuminate\Foundation\Bootstrap\BootProviders::class,                    # 注册启动器   ];</code></pre><p>这三个核心成员变量就是引导咱们更快理清 $app-&gt;kernel-&gt;handle(网络请求) 的最好导游：</p><p>$app 咱们已经说了足够多，就是应用容器，我们所有的工作都在这个容器中进行。</p><p>$router 路由对象，它提供路由相关的服务，帮助我们把网络请求分配给对应的路由进行逻辑处理，然后把处理的结果（网络响应）返回给我们，我们在 web.php 中定义的路由就是由它来管理的。</p><p>$bootstrappers 数组，这个数组中的任务项在网络请求被处理前运行，我们可以看到 <strong>环境检查，配置加载，异常处理，Facedes 门面注册，ServiceProvider 注册</strong>  等等任务都需要在网络请求被处理前被首先执行，而且这些任务是有前后顺序的，排在前面的会首先执行，这也很容易理解，因为不管是 Facades 还是  Service Providers 都是定义在 config 目录中的 app.php  文件中的，只有加载来配置之后才能注册门面和Service Providers。</p><p>然后咱们再来看看 $app-&gt;kernel 的构造函数，在这里咱们看到了一个脸熟的不能再熟的老朋友 — Middleware ，在 Kernel 以及它的基类 Illuminate\Foundation\Http\Kernel 中定义了一系列的 middlewares ，借助这些中间件，就可以完成对用户请求的过滤和安全检查等等功能。</p><pre><code>  public function __construct(Application $app, Router $router)  {      $this-&gt;app = $app;      $this-&gt;router = $router;      $router-&gt;middlewarePriority = $this-&gt;middlewarePriority;      foreach ($this-&gt;middlewareGroups as $key =&gt; $middleware) {          $router-&gt;middlewareGroup($key, $middleware);      }    foreach ($this-&gt;routeMiddleware as $key =&gt; $middleware) {          $router-&gt;aliasMiddleware($key, $middleware);      }  }</code></pre><p>至此咱们还是终于可以绕回来进入  $app-&gt;kernel-&gt;handle($request) 看一看它是如何处理网络请求的吧，下面这张图结合第一张图会更清楚一些，接下来的内容实在不想贴代码了：</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5nlwm23qsj20yh0n60u6.jpg" alt></p><p><strong>4.  结束请求，进行回调，终止 Laravel 应用，Laravel 到此也完成了它的历史使命。中间件中有一类的中间件，terminable middleware 的处理逻辑就是在这个阶段执行的。</strong></p><p>文章写到这里基本上就结束了，太多细节我们并没有涉及，要靠诸君亲力亲为了，我呢，还是那些话，不要在一开始的阶段就去学习<br>laravel 的生命周期，等你用 laravel<br>工作了一段时间，对它的使用方法和核心概念都清楚了之后再来学习，基本上就是一件很容易的事了。最后附上一张大图，梳理一下整个流程，也作为文章的结束吧。</p><p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5nlxvljmaj21e00zc1kx.jpg" alt></p><blockquote><p>原文地址：</p><p><a href="http://www.coding10.com/book/laravel-lifecircle" target="_blank" rel="noopener">http://www.coding10.com/book/laravel-lifecircle</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-生命周期 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-自定义表单验证规则类与闭包验证</title>
      <link href="/2019/08/02/Laravel%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99%E4%B8%8E%E9%97%AD%E5%8C%85%E9%AA%8C%E8%AF%81/"/>
      <url>/2019/08/02/Laravel%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E8%A7%84%E5%88%99%E4%B8%8E%E9%97%AD%E5%8C%85%E9%AA%8C%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Laravel 提供了许多有用的验证规则；同时也支持自定义规则。注册自定义验证规则的方法之一，就是使用规则对象。可以使用 Artisan 命令 make:rule 来生成新的规则对象。接下来，让我们用这个命令生成一个验证字符串是大写的规则。Laravel 会将新的规则存放在 app/Rules 目录中：</p><pre><code>php artisan make:rule UserRule</code></pre><p>在我们实际项目当中，很多地方都用的到表单的验证，比如说：登录与注册、手机号码验证、用户格式限定等等</p><p>我们就直接可以在自定义表单验证规则当中，进行逻辑的编写进行表单的有效性和合法性的验证，这样的好处在于，代码的复用性和后期维护成本上来都非常好，也是一目了然的操作。</p><h3 id="简单说明"><a href="#简单说明" class="headerlink" title="简单说明"></a>简单说明</h3><p>通过 Artisan 命令创建了自定义的表单验证规则</p><pre><code>class UserRule implements Rule{    /**     * Create a new rule instance.     *`     * @return void     */    public function __construct()    {    //    }    /**     * Determine if the validation rule passes.     *     * @param  string  $attribute 规则字段     * @param  mixed  $value 字段的值     * @return mixed     */    public function passes($attribute, $value)    {        if ($result = DB::table(&#39;admins&#39;)-&gt;where($attribute,&#39;=&#39;,$value)-&gt;first())        {            config()-&gt;set(&#39;user_name&#39;,$result);            return true;        }else{            return false;        }    }    /**     * Get the validation error message.     *     * @return mixed     */    public function message()    {        return &#39;账号信息不正确&#39;;    }}</code></pre><p>我们可以清楚的看见，他是实现 Rule 这个接口，当我点击 Rule 跳转到 Rule 接口时，可以清楚的看见他里面就二个抽象方法</p><pre><code>interface Rule{    /**     * Determine if the validation rule passes.     *     * @param  string  $attribute     * @param  mixed  $value     * @return bool     */    public function passes($attribute, $value);    /**     * Get the validation error message.     *     * @return string|array     */    public function message();}</code></pre><p>一个 passes 方法和一个 message 抽象方法，在接口当中只能有类常量和抽象方法，要去实现抽象方法，要么成为抽象类要么实现里面所有的抽象方法。</p><p>在我们自定义的表单验证规则当中，我们已经实现了抽象方法 passes 和 message</p><p>先来说说 passes 这方法，他有二个参数 $attribute 和 $value 他们表示什么呢？</p><p>$attribute 表示当前字段，$value 表示当前字段的值  我们 dump 一下就可以一目了然了</p><img src="http://ww1.sinaimg.cn/large/e73160eely1g5lq13uo7jj21bp0gmtcd.jpg"><p>当我们知道这个参数代表什么基本也就晓得 passes 能做什么了，当我们自定义的验证规则通过了，我们就可以返回一个 true，如果说验证规则我们就返回一个 false，而 message 这个方法，如果接收的是 false 那么他就可以返回一段错误验证的信息！</p><p>当然有时候这样的自定义验证规则操作起来可能确实有些麻烦，Laravel 也给我另外一种自定义的验证规则</p><h3 id="闭包验证"><a href="#闭包验证" class="headerlink" title="闭包验证"></a>闭包验证</h3><p>如果你在应用程序中只需要一次自定义规则的功能，则可以使用闭包而不是规则对象。闭包接收属性的名称，属性的值如果验证失败则应该使用回调中的 $fail</p><pre><code>$validator = Validator::make($request-&gt;all(), [    &#39;title&#39; =&gt; [        &#39;required&#39;,        &#39;max:255&#39;,        function ($attribute, $value, $fail) {            if ($value === &#39;foo&#39;) {                $fail($attribute.&#39; is invalid.&#39;);            }        },    ],]);</code></pre>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-表单验证操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laravel-自定义表单验证类</title>
      <link href="/2019/08/01/Laravel%E4%B9%8B%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E7%B1%BB/"/>
      <url>/2019/08/01/Laravel%E4%B9%8B%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>Laravel 提供了几种不同的方法来验证传入应用程序的数据。默认情况下，Laravel 的控制器基类使用 ValidatesRequests Trait，它提供了一种方便的方法去使用各种强大的验证规则来验证传入的 HTTP 请求。</p><h3 id="表单验证类的好处"><a href="#表单验证类的好处" class="headerlink" title="表单验证类的好处"></a>表单验证类的好处</h3><p>一般我们的情况下，我们都是在 Controller 里面写表单验证的逻辑规则然后返回信息错误信息。这样我们的业务和表单逻辑都放在了一起，复用性很差，在要用的基本就是复制和粘贴！</p><p>那么我们可以选择把表单验证独立出来，创建一个表单的验证类，这样复用性也很高，Controller 里面也专注与业务！</p><h3 id="创建表单验证类与操作流程"><a href="#创建表单验证类与操作流程" class="headerlink" title="创建表单验证类与操作流程"></a>创建表单验证类与操作流程</h3><pre><code>php artisan make:request BaseRequest</code></pre><p>创建一个 Base 类，他用来继承与 FormRequest，而我们以后所有的验证类都继承 BaseRequest</p><pre><code>class BaseRequest extends FormRequest{    // 验证是否有权限    public function authorize()    {        return true;    }    public function failedValidation($validator)    {        $response = $validator-&gt;errors()-&gt;first();        throw new ApiErrorException($response,503);    }}</code></pre><h3 id="为什么我们要抛出异常呢？"><a href="#为什么我们要抛出异常呢？" class="headerlink" title="为什么我们要抛出异常呢？"></a>为什么我们要抛出异常呢？</h3><p>Laravel 在验证错误之后，<strong>会自动错误闪存到 Session 当中，并且自动重定向到之前的位置</strong>。Laravel 会自动检测到 Session 当中的错误信息，并且自动绑定到视图当中。如果是 AJAX 请求，会生成一个包含所有验证错误信息的 JSON 响应。这个 JSON 响应会包含一个 HTTP 状态码 422 被发送出去。而我们需要做的就是自定义异常的抛出，来控制错误返回，不需要框架来完成。</p><p>在我们定义 Base 的访问权限为 TRUE 之后，有自定义了异常的抛出。那么此时就可以创建自己需要的验证类了</p><pre><code>php artisan make:request UserRequest</code></pre><pre><code>class UserRequest extends BaseRequest{    public function rules()    {        return [            &#39;user&#39; =&gt; &#39;required&#39;,            &#39;password&#39; =&gt; &#39;required&#39;        ];    }    public function messages()    {        return [            &#39;user.required&#39; =&gt; &#39;账号不能为空&#39;,            &#39;password.required&#39; =&gt; &#39;密码不能为空&#39;,        ];    }}</code></pre><ul><li>rules ：是验证规则</li><li>messages ：是自定义错误的信息</li></ul><p>他们都是自动去调用执行我们不需要去关心他们的执行，只需要知道一个是规则验证一个是返回的错误信息，还有有是他执行后错误的处理，上面也说了一个是闪存 Session 然后重定向一个，一个是 AJAX JSON 的返回！</p><blockquote><p>验证规则是如何运行的呢？你所需要做的就是在控制器方法中类型提示传入的请求。在调用控制器方法之前验证传入的表单请求，这意味着你不需要在控制器中写任何验证逻辑</p></blockquote><p>有了异常抛出，有了规则验证和错误信息，我们该如何使用呢？</p><pre><code>public function login(UserRequest $request){}</code></pre><p>依赖注入，当我们把这个验证类依赖注入到我们要使用的 Controller 中。</p><p>执行流程：如果说，我们的规则验证不通过，那么我们就会自动抛出异常，程序不会继续向下执行，如果说验证没有问题，那么程序顺序执行！</p>]]></content>
      
      
      <categories>
          
          <category> Laravel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Laravel-表单验证操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扬帆启航</title>
      <link href="/2019/08/01/%E5%A4%9A%E5%A4%9A%E5%85%B3%E7%85%A7/"/>
      <url>/2019/08/01/%E5%A4%9A%E5%A4%9A%E5%85%B3%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在无意间查询一篇资料的时候进入到了[韦阳]的博客，第一眼就被他博客的 UI 界面吸引了，让我看起来觉得很舒服很爽！！！啊…爽！！！我本身也是比较喜欢写博文，不！我还没达不到自我写博文的时候，应该说我本身也比较喜欢记录学习。以前用过博客园、看云，但是总体上来说感觉都属于 “集中” 虽然可以自我美化，但是都没我第一眼看到[韦阳]博客的那种喜欢感觉。喜欢就走起，了解下来发现是基于 Github + Hexo 。耗时 2 天，终于搭建好个性化完成了，不容易啊！</p><p>在[韦阳]的博客首页推荐文章当中就有博客搭建的详细教程。</p><blockquote><p><a href="https://godweiyang.com/2018/04/13/hexo-blog/" target="_blank" rel="noopener">https://godweiyang.com/2018/04/13/hexo-blog/</a></p></blockquote><p>扬帆、启航</p><p><img src="https://i.loli.net/2019/09/03/RWBTwtkD2MjPavh.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 启航 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 启航 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
